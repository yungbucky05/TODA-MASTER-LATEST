<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TODA-MASTER-LATEST/esp.ino">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TODA-MASTER-LATEST/esp.ino" />
              <option name="originalContent" value="#include &lt;WiFi.h&gt;&#10;#include &lt;Firebase_ESP_Client.h&gt;&#10;#include &lt;addons/TokenHelper.h&gt;&#10;#include &lt;addons/RTDBHelper.h&gt;&#10;#include &lt;WiFiClientSecure.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;Wire.h&gt;&#10;#include &lt;SPI.h&gt;&#10;#include &lt;Adafruit_PN532.h&gt;&#10;#include &lt;LiquidCrystal_I2C.h&gt;&#10;&#10;// WiFi credentials&#10;#define WIFI_SSID &quot;George&quot;&#10;#define WIFI_PASSWORD &quot;Aixroch!092601&quot;&#10;&#10;// Firebase credentials&#10;#define API_KEY &quot;AIzaSyAbEJ8tzm5RIeXvKhlxZl71a_tBX4WmN4E&quot;&#10;#define DATABASE_URL &quot;https://toda-contribution-system-default-rtdb.asia-southeast1.firebasedatabase.app/&quot;&#10;#define USER_EMAIL &quot;test@example.com&quot;&#10;#define USER_PASSWORD &quot;test123456&quot;&#10;&#10;// I2C LCD configuration&#10;#define LCD_SDA 21&#10;#define LCD_SCL 22&#10;#define LCD_ADDRESS 0x27  // Common I2C address for LCD, may need to change to 0x3F&#10;&#10;// PN532 SPI configuration&#10;#define PN532_SCK  18&#10;#define PN532_MOSI 23&#10;#define PN532_SS   5&#10;#define PN532_MISO 19&#10;&#10;// Serial communication to Arduino (TX only)&#10;#define ARDUINO_TX 17&#10;&#10;// Coin pulse input pin (coin acceptor signal wire connected directly to ESP32)&#10;#define COIN_PULSE_PIN 32&#10;&#10;// New: Standardized contribution amount&#10;const int CONTRIBUTION_AMOUNT = 5;&#10;&#10;// Create instances&#10;Adafruit_PN532 nfc(PN532_SCK, PN532_MISO, PN532_MOSI, PN532_SS);&#10;LiquidCrystal_I2C lcd(LCD_ADDRESS, 16, 2);  // 16x2 LCD display&#10;&#10;// Firebase objects&#10;FirebaseData fbdo;&#10;FirebaseAuth auth;&#10;FirebaseConfig config;&#10;&#10;// System state&#10;bool coinSlotEnabled = false;&#10;bool nfcEnabled = true;&#10;unsigned long lastNFCCheck = 0;&#10;const unsigned long NFC_CHECK_INTERVAL = 100;&#10;unsigned long totalSavings = 0;&#10;&#10;// Coin pulse detection (direct on ESP32)&#10;volatile unsigned long coinLastPulseUs = 0;&#10;// Count only VALID pulses based on width&#10;volatile uint16_t coinValidPulses = 0;&#10;// Active level configuration: runtime-tunable (true = active LOW, false = active HIGH)&#10;volatile bool coinActiveLow = true;&#10;// Track active state to measure pulse width&#10;volatile bool coinActive = false;&#10;volatile unsigned long coinActiveStartUs = 0;&#10;volatile unsigned long lastValidPulseWidthUs = 0;&#10;volatile uint32_t coinRawEdges = 0; // counts all CHANGE edges for diagnostics&#10;&#10;// Timing thresholds (runtime-tunable)&#10;volatile unsigned long coinGapUs = 350000UL;            // end of burst when quiet &gt; 350ms&#10;volatile unsigned long coinPowerStabilizeMs = 4000UL;   // wait 4s after power on&#10;volatile unsigned long minPulseUs = 2000UL;             // min active width = 2ms (filter spikes)&#10;volatile unsigned long maxPulseUs = 200000UL;           // max active width = 200ms (filter long noise)&#10;volatile uint8_t minBurstPulses = 1;                    // require N valid pulses before accepting a coin&#10;unsigned long coinSlotPowerOnTime = 0;&#10;&#10;// Add RFID debounce variables&#10;String lastScannedUID = &quot;&quot;;&#10;unsigned long lastScanTime = 0;&#10;const unsigned long SCAN_DEBOUNCE_TIME = 3000; // 3 seconds between same card scans&#10;bool isProcessingRFID = false;&#10;&#10;// Add Firebase timeout variables&#10;unsigned long firebaseTimeout = 10000; // 10 seconds timeout&#10;&#10;// Driver information structure&#10;struct Driver {&#10;    String rfidUID;&#10;    String todaNumber;&#10;    String driverName;&#10;    bool isRegistered;&#10;    // New fields&#10;    String driverId;&#10;    String paymentMode; // &quot;pay_every_trip&quot; or &quot;pay_later&quot;&#10;};&#10;&#10;// Global variable to store current driver info&#10;Driver currentDriver;&#10;&#10;// Queue management&#10;String firstDriverQueueKey = &quot;&quot;;&#10;&#10;// Function forward declarations&#10;void checkForRFIDCard();&#10;void checkDriverRegistration(String rfidUID);&#10;void enableCoinSlot(Driver driver);&#10;void processCoinContribution();&#10;void processContributionAndQueue();&#10;void recordContribution();&#10;void addDriverToQueue();&#10;// New forward declarations&#10;void processPayLaterAndQueue(Driver driver);&#10;void addDriverToQueueWithPaid(bool paid);&#10;void showError(String message);&#10;void updateLCDDisplay(String todaNumber, String message);&#10;void clearLCDDisplay();&#10;String getCurrentDate();&#10;String getCurrentTime();&#10;&#10;// ISR for coin pulse&#10;void IRAM_ATTR coinISR() {&#10;    int level = digitalRead(COIN_PULSE_PIN);&#10;    unsigned long nowUs = micros();&#10;&#10;    coinRawEdges++;&#10;&#10;    bool isActive = coinActiveLow ? (level == LOW) : (level == HIGH);&#10;&#10;    if (isActive) {&#10;        if (!coinActive) {&#10;            coinActive = true;&#10;            coinActiveStartUs = nowUs;&#10;        }&#10;    } else { // inactive edge&#10;        if (coinActive) {&#10;            unsigned long width = nowUs - coinActiveStartUs;&#10;            coinActive = false;&#10;            // Validate pulse width&#10;            if (width &gt;= minPulseUs &amp;&amp; width &lt;= maxPulseUs) {&#10;                coinValidPulses++;&#10;                coinLastPulseUs = nowUs;&#10;                lastValidPulseWidthUs = width;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;void setup() {&#10;    Serial.begin(115200);&#10;    // Initialize Serial2 as TX-only (rxPin = -1) to command Arduino, no RX wire connected&#10;    Serial2.begin(9600, SERIAL_8N1, -1, ARDUINO_TX);&#10;&#10;    // Initialize coin pulse input&#10;    pinMode(COIN_PULSE_PIN, INPUT_PULLUP);&#10;    // Use CHANGE to measure pulse width accurately&#10;    attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#10;&#10;    // Initialize I2C for LCD with custom pins&#10;    Wire.begin(LCD_SDA, LCD_SCL);&#10;&#10;    // Initialize LCD&#10;    lcd.init();&#10;    lcd.backlight();&#10;    lcd.clear();&#10;&#10;    // Display startup message&#10;    lcd.setCursor(0, 0);&#10;    lcd.print(&quot;TODA System&quot;);&#10;    lcd.setCursor(0, 1);&#10;    lcd.print(&quot;Starting...&quot;);&#10;&#10;    Serial.println(&quot;ESP32 ready: TODA Contribution &amp; Queueing System&quot;);&#10;    Serial.println(&quot;Serial2 initialized: TX=17 (TX-only, no RX)&quot;);&#10;    Serial.print(&quot;LCD initialized: SDA=Pin&quot;);&#10;    Serial.print(LCD_SDA);&#10;    Serial.print(&quot;, SCL=Pin&quot;);&#10;    Serial.println(LCD_SCL);&#10;    Serial.println(&quot;Coin pulse input on pin 16 with interrupt (CHANGE)&quot;);&#10;    Serial.print(&quot;Coin polarity: active-&quot;);&#10;    Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#10;&#10;    // Initialize WiFi&#10;    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);&#10;    Serial.print(&quot;Connecting to WiFi&quot;);&#10;    while (WiFi.status() != WL_CONNECTED) {&#10;        delay(300);&#10;        Serial.print(&quot;.&quot;);&#10;    }&#10;    Serial.println();&#10;    Serial.print(&quot;Connected with IP: &quot;);&#10;    Serial.println(WiFi.localIP());&#10;&#10;    // Configure time (needed for Firebase)&#10;    configTime(8 * 3600, 0, &quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);  // GMT+8 Philippines&#10;&#10;    // Wait for time to be set&#10;    Serial.print(&quot;Waiting for NTP time sync&quot;);&#10;    time_t now = time(nullptr);&#10;    while (now &lt; 8 * 3600 * 2) {&#10;        delay(500);&#10;        Serial.print(&quot;.&quot;);&#10;        now = time(nullptr);&#10;    }&#10;    Serial.println();&#10;    Serial.println(&quot;Time synchronized&quot;);&#10;&#10;    // Initialize Firebase&#10;    config.api_key = API_KEY;&#10;    config.database_url = DATABASE_URL;&#10;&#10;    // Use email/password authentication&#10;    Serial.println(&quot;Initializing Firebase with email authentication...&quot;);&#10;&#10;    // Set user credentials&#10;    auth.user.email = USER_EMAIL;&#10;    auth.user.password = USER_PASSWORD;&#10;&#10;    // Assign the callback function for the long running token generation task&#10;    config.token_status_callback = tokenStatusCallback;&#10;&#10;    Firebase.begin(&amp;config, &amp;auth);&#10;    Firebase.reconnectWiFi(true);&#10;&#10;    // Set timeout&#10;    fbdo.setResponseSize(4096);&#10;&#10;    Serial.println(&quot;Firebase configuration complete&quot;);&#10;&#10;    // Wait for Firebase authentication&#10;    Serial.print(&quot;Waiting for Firebase authentication&quot;);&#10;    unsigned long startTime = millis();&#10;    while (!Firebase.ready() &amp;&amp; (millis() - startTime &lt; 30000)) {&#10;        delay(1000);&#10;        Serial.print(&quot;.&quot;);&#10;    }&#10;&#10;    if (Firebase.ready()) {&#10;        Serial.println();&#10;        Serial.println(&quot;✓ Firebase authenticated and ready!&quot;);&#10;&#10;        // Test database connection&#10;        if (Firebase.RTDB.get(&amp;fbdo, &quot;/drivers&quot;)) {&#10;            Serial.println(&quot;✓ Database connection successful!&quot;);&#10;        } else {&#10;            Serial.println(&quot;Database test result: &quot; + fbdo.errorReason());&#10;        }&#10;    } else {&#10;        Serial.println();&#10;        Serial.println(&quot;✗ Firebase authentication failed&quot;);&#10;    }&#10;&#10;    // Initialize PN532&#10;    nfc.begin();&#10;    uint32_t versiondata = nfc.getFirmwareVersion();&#10;    if (!versiondata) {&#10;        Serial.println(&quot;PN532 not found&quot;);&#10;    } else {&#10;        Serial.print(&quot;Found PN532 with firmware version: &quot;);&#10;        Serial.println((versiondata &gt;&gt; 16) &amp; 0xFF, HEX);&#10;        nfc.SAMConfig();&#10;        Serial.println(&quot;PN532 ready, waiting for driver RFID...&quot;);&#10;    }&#10;&#10;&#10;    Serial.println(&quot;System ready: Please scan driver RFID card to start contribution process&quot;);&#10;&#10;    // Update LCD with system ready message&#10;    lcd.clear();&#10;    lcd.setCursor(0, 0);&#10;    lcd.print(&quot;System Ready&quot;);&#10;    lcd.setCursor(0, 1);&#10;    lcd.print(&quot;Scan RFID Card&quot;);&#10;}&#10;&#10;void loop() {&#10;    // DIRECT COIN PULSE HANDLING (no Serial2 RX)&#10;    if (coinSlotEnabled) {&#10;        // Check if a pulse burst has finished&#10;        noInterrupts();&#10;        uint16_t pulses = coinValidPulses;&#10;        unsigned long lastUs = coinLastPulseUs;&#10;        bool activeNow = coinActive;&#10;        unsigned long lastWidth = lastValidPulseWidthUs;&#10;        interrupts();&#10;&#10;        // Only act after initial power stabilization&#10;        if (millis() - coinSlotPowerOnTime &lt; coinPowerStabilizeMs) {&#10;            // Clear any early pulses as noise during stabilization&#10;            if (pulses &gt; 0 || activeNow) {&#10;                noInterrupts();&#10;                coinValidPulses = 0;&#10;                coinActive = false;&#10;                interrupts();&#10;            }&#10;        } else {&#10;            // When we have a sufficient number of valid pulses and quiet period, process&#10;            if (pulses &gt;= minBurstPulses &amp;&amp; (micros() - lastUs &gt; coinGapUs) &amp;&amp; !activeNow) {&#10;                Serial.print(&quot;Coin burst validated - pulses: &quot;);&#10;                Serial.print(pulses);&#10;                Serial.print(&quot;, last width(us): &quot;);&#10;                Serial.println(lastWidth);&#10;&#10;                // Reset counters before processing to avoid re-entry&#10;                noInterrupts();&#10;                coinValidPulses = 0;&#10;                coinActive = false;&#10;                interrupts();&#10;&#10;                processCoinContribution();&#10;            }&#10;        }&#10;    } else {&#10;        // If disabled, clear any accumulated pulses silently&#10;        if (coinValidPulses &gt; 0 || coinActive) {&#10;            noInterrupts();&#10;            coinValidPulses = 0;&#10;            coinActive = false;&#10;            interrupts();&#10;        }&#10;    }&#10;&#10;    // Check for NFC cards (only when enabled)&#10;    if (nfcEnabled &amp;&amp; (millis() - lastNFCCheck &gt;= NFC_CHECK_INTERVAL)) {&#10;        lastNFCCheck = millis();&#10;        checkForRFIDCard();&#10;    }&#10;&#10;    // Debug system status every 10 seconds&#10;    static unsigned long lastSystemStatus = 0;&#10;    if (millis() - lastSystemStatus &gt; 10000) {&#10;        Serial.println(&quot;System Status - NFC: &quot; + String(nfcEnabled ? &quot;ON&quot; : &quot;OFF&quot;) +&#10;                       &quot;, CoinSlot: &quot; + String(coinSlotEnabled ? &quot;ON&quot; : &quot;OFF&quot;) +&#10;                       &quot;, ProcessingRFID: &quot; + String(isProcessingRFID ? &quot;YES&quot; : &quot;NO&quot;));&#10;        lastSystemStatus = millis();&#10;    }&#10;&#10;    // Check for manual commands via Serial Monitor (for debugging)&#10;    if (Serial.available()) {&#10;        String command = Serial.readString();&#10;        command.trim();&#10;        command.toLowerCase();&#10;&#10;        if (command == &quot;enable&quot;) {&#10;            Serial.println(&quot;Manually enabling coin slot...&quot;);&#10;            Driver testDriver;&#10;            testDriver.rfidUID = &quot;MANUAL&quot;;&#10;            testDriver.driverName = &quot;Manual Test&quot;;&#10;            testDriver.todaNumber = &quot;TEST&quot;;&#10;            testDriver.isRegistered = true;&#10;            enableCoinSlot(testDriver);&#10;        } else if (command == &quot;disable&quot;) {&#10;            Serial.println(&quot;Manually disabling coin slot...&quot;);&#10;            coinSlotEnabled = false;&#10;            nfcEnabled = true;&#10;            Serial2.write((uint8_t)201);&#10;            Serial2.flush();&#10;            // Clear any pending coin pulses&#10;            noInterrupts();&#10;            coinValidPulses = 0;&#10;            coinActive = false;&#10;            interrupts();&#10;            Serial.println(&quot;Coin slot disabled, NFC re-enabled&quot;);&#10;        } else if (command == &quot;status&quot;) {&#10;            Serial.println(&quot;\n=== SYSTEM STATUS ===&quot;);&#10;            Serial.println(&quot;NFC Enabled: &quot; + String(nfcEnabled ? &quot;true&quot; : &quot;false&quot;));&#10;            Serial.println(&quot;Coin Slot Enabled: &quot; + String(coinSlotEnabled ? &quot;true&quot; : &quot;false&quot;));&#10;            Serial.println(&quot;Processing RFID: &quot; + String(isProcessingRFID ? &quot;true&quot; : &quot;false&quot;));&#10;            Serial.println(&quot;WiFi Status: &quot; + String(WiFi.status() == WL_CONNECTED ? &quot;Connected&quot; : &quot;Disconnected&quot;));&#10;            Serial.println(&quot;Firebase Ready: &quot; + String(Firebase.ready() ? &quot;true&quot; : &quot;false&quot;));&#10;            Serial.println(&quot;==================&quot;);&#10;        } else if (command == &quot;test200&quot;) {&#10;            Serial.println(&quot;Sending command 200 to Arduino...&quot;);&#10;            Serial2.write((uint8_t)200);&#10;            Serial2.flush();&#10;            Serial.println(&quot;Command 200 sent!&quot;);&#10;        } else if (command == &quot;test201&quot;) {&#10;            Serial.println(&quot;Sending command 201 to Arduino...&quot;);&#10;            Serial2.write((uint8_t)201);&#10;            Serial2.flush();&#10;            Serial.println(&quot;Command 201 sent!&quot;);&#10;        } else if (command == &quot;queue&quot;) {&#10;            Serial.println(&quot;Checking driver queue status...&quot;);&#10;            checkQueueStatus();&#10;&#10;        } else if (command.startsWith(&quot;coinpol&quot;)) {&#10;            if (command.indexOf(&quot;high&quot;) != -1) {&#10;                coinActiveLow = false;&#10;                Serial.println(&quot;Coin polarity set to ACTIVE-HIGH&quot;);&#10;            } else if (command.indexOf(&quot;low&quot;) != -1) {&#10;                coinActiveLow = true;&#10;                Serial.println(&quot;Coin polarity set to ACTIVE-LOW&quot;);&#10;            } else {&#10;                Serial.println(&quot;Usage: coinpol low|high&quot;);&#10;            }&#10;        } else if (command == &quot;coinstat&quot;) {&#10;            noInterrupts();&#10;            uint16_t pulses = coinValidPulses;&#10;            bool activeNow = coinActive;&#10;            unsigned long lastWidth = lastValidPulseWidthUs;&#10;            uint32_t edges = coinRawEdges;&#10;            int pinLevel = digitalRead(COIN_PULSE_PIN);&#10;            interrupts();&#10;            Serial.println(&quot;=== COIN INPUT STATUS ===&quot;);&#10;            Serial.print(&quot;Polarity: ACTIVE-&quot;); Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#10;            Serial.print(&quot;Pin level: &quot;); Serial.println(pinLevel == HIGH ? &quot;HIGH&quot; : &quot;LOW&quot;);&#10;            Serial.print(&quot;Valid pulses (since enable): &quot;); Serial.println(pulses);&#10;            Serial.print(&quot;Raw edges (since boot): &quot;); Serial.println(edges);&#10;            Serial.print(&quot;Last valid pulse width (us): &quot;); Serial.println(lastWidth);&#10;            Serial.print(&quot;Active now: &quot;); Serial.println(activeNow ? &quot;YES&quot; : &quot;NO&quot;);&#10;            Serial.print(&quot;Millis since power-on of slot: &quot;); Serial.println(millis() - coinSlotPowerOnTime);&#10;            Serial.println(&quot;=========================&quot;);&#10;        } else if (command.startsWith(&quot;coinpull&quot;)) {&#10;            if (command.indexOf(&quot;up&quot;) != -1) {&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#10;                pinMode(COIN_PULSE_PIN, INPUT_PULLUP);&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#10;                Serial.println(&quot;Coin pin mode: INPUT_PULLUP&quot;);&#10;            } else if (command.indexOf(&quot;down&quot;) != -1) {&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#10;                pinMode(COIN_PULSE_PIN, INPUT_PULLDOWN);&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#10;                Serial.println(&quot;Coin pin mode: INPUT_PULLDOWN&quot;);&#10;            } else if (command.indexOf(&quot;float&quot;) != -1) {&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#10;                pinMode(COIN_PULSE_PIN, INPUT);&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#10;                Serial.println(&quot;Coin pin mode: INPUT (floating)&quot;);&#10;            } else {&#10;                Serial.println(&quot;Usage: coinpull up|down|float&quot;);&#10;            }&#10;        } else if (command.startsWith(&quot;coinset&quot;)) {&#10;            // coinset min 500 | max 300000 | gap 400000 | stab 3000 | burst 1&#10;            // parse simple tokens&#10;            if (command.indexOf(&quot;min&quot;) != -1) {&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#10;                if (v &gt; 50 &amp;&amp; v &lt; 1000000) { minPulseUs = (unsigned long)v; Serial.print(&quot;minPulseUs=&quot;); Serial.println(minPulseUs); }&#10;                else Serial.println(&quot;min must be 50..1000000 us&quot;);&#10;            } else if (command.indexOf(&quot;max&quot;) != -1) {&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#10;                if (v &gt; 100 &amp;&amp; v &lt; 2000000) { maxPulseUs = (unsigned long)v; Serial.print(&quot;maxPulseUs=&quot;); Serial.println(maxPulseUs); }&#10;                else Serial.println(&quot;max must be 100..2000000 us&quot;);&#10;            } else if (command.indexOf(&quot;gap&quot;) != -1) {&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#10;                if (v &gt; 1000 &amp;&amp; v &lt; 3000000) { coinGapUs = (unsigned long)v; Serial.print(&quot;coinGapUs=&quot;); Serial.println(coinGapUs); }&#10;                else Serial.println(&quot;gap must be 1000..3000000 us&quot;);&#10;            } else if (command.indexOf(&quot;stab&quot;) != -1) {&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#10;                if (v &gt;= 0 &amp;&amp; v &lt; 30000) { coinPowerStabilizeMs = (unsigned long)v; Serial.print(&quot;coinPowerStabilizeMs=&quot;); Serial.println(coinPowerStabilizeMs); }&#10;                else Serial.println(&quot;stab must be 0..30000 ms&quot;);&#10;            } else if (command.indexOf(&quot;burst&quot;) != -1) {&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#10;                if (v &gt;= 1 &amp;&amp; v &lt;= 10) { minBurstPulses = (uint8_t)v; Serial.print(&quot;minBurstPulses=&quot;); Serial.println(minBurstPulses); }&#10;                else Serial.println(&quot;burst must be 1..10&quot;);&#10;            } else {&#10;                Serial.println(&quot;Usage: coinset min|max|gap|stab|burst &lt;value&gt;&quot;);&#10;            }&#10;        } else if (command == &quot;coinshow&quot;) {&#10;            Serial.println(&quot;=== COIN SETTINGS ===&quot;);&#10;            Serial.print(&quot;Polarity: ACTIVE-&quot;); Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#10;            Serial.print(&quot;Pin mode: &quot;);&#10;            // can't directly read mode; show suggestion&#10;            Serial.println(&quot;see last coinpull command&quot;);&#10;            Serial.print(&quot;minPulseUs=&quot;); Serial.println(minPulseUs);&#10;            Serial.print(&quot;maxPulseUs=&quot;); Serial.println(maxPulseUs);&#10;            Serial.print(&quot;coinGapUs=&quot;); Serial.println(coinGapUs);&#10;            Serial.print(&quot;coinPowerStabilizeMs=&quot;); Serial.println(coinPowerStabilizeMs);&#10;            Serial.print(&quot;minBurstPulses=&quot;); Serial.println(minBurstPulses);&#10;            Serial.println(&quot;=====================&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;void checkQueueStatus() {&#10;    Serial.println(&quot;\n=== DRIVER QUEUE STATUS ===&quot;);&#10;&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#10;            String jsonStr = fbdo.jsonString();&#10;&#10;            if (jsonStr == &quot;null&quot; || jsonStr.length() == 0) {&#10;                Serial.println(&quot;Queue is empty&quot;);&#10;            } else {&#10;                Serial.println(&quot;Queue data:&quot;);&#10;&#10;                // Parse and display queue entries with readable timestamps&#10;                int driverCount = 0;&#10;                int pos = 0;&#10;                while ((pos = jsonStr.indexOf(&quot;\&quot;driverName\&quot;&quot;, pos)) != -1) {&#10;                    driverCount++;&#10;&#10;                    // Find the driver name&#10;                    int nameStart = jsonStr.indexOf(&quot;\&quot;&quot;, pos + 12) + 1;&#10;                    int nameEnd = jsonStr.indexOf(&quot;\&quot;&quot;, nameStart);&#10;                    String driverName = jsonStr.substring(nameStart, nameEnd);&#10;&#10;                    // Find the timestamp (look backwards for the key)&#10;                    int keyEnd = jsonStr.lastIndexOf(&quot;\&quot;:&quot;, pos);&#10;                    int keyStart = jsonStr.lastIndexOf(&quot;\&quot;&quot;, keyEnd - 1) + 1;&#10;                    String queueKey = jsonStr.substring(keyStart, keyEnd);&#10;&#10;                    // Find the readable timestamp&#10;                    int timestampPos = jsonStr.indexOf(&quot;\&quot;timestamp\&quot;:&quot;, pos);&#10;                    String readableTime = &quot;&quot;;&#10;                    if (timestampPos != -1 &amp;&amp; timestampPos &lt; jsonStr.indexOf(&quot;\&quot;driverName\&quot;&quot;, pos + 1)) {&#10;                        int timeStart = jsonStr.indexOf(&quot;\&quot;&quot;, timestampPos + 12) + 1;&#10;                        int timeEnd = jsonStr.indexOf(&quot;\&quot;&quot;, timeStart);&#10;                        readableTime = jsonStr.substring(timeStart, timeEnd);&#10;                    }&#10;&#10;                    Serial.println(&quot;Driver #&quot; + String(driverCount) + &quot;: &quot; + driverName +&#10;                                   &quot; (Queue: &quot; + queueKey + &quot;, Time: &quot; + readableTime + &quot;)&quot;);&#10;&#10;                    pos++;&#10;                }&#10;                Serial.println(&quot;Total drivers in queue: &quot; + String(driverCount));&#10;            }&#10;        } else {&#10;            Serial.println(&quot;Queue data type: &quot; + fbdo.dataType());&#10;        }&#10;    } else {&#10;        // Firebase removes empty nodes, so &quot;path not exist&quot; means no drivers in queue&#10;        if (fbdo.errorReason().indexOf(&quot;path not exist&quot;) != -1 ||&#10;            fbdo.errorReason().indexOf(&quot;not found&quot;) != -1 ||&#10;            fbdo.httpCode() == 404) {&#10;            Serial.println(&quot;No drivers available in queue&quot;);&#10;        } else {&#10;            Serial.println(&quot;✗ Failed to get queue: &quot; + fbdo.errorReason());&#10;        }&#10;    }&#10;&#10;    Serial.println(&quot;===========================\n&quot;);&#10;}&#10;&#10;&#10;&#10;&#10;void checkForRFIDCard() {&#10;    // Don't check for RFID if we're already processing one&#10;    if (isProcessingRFID) {&#10;        return;&#10;    }&#10;&#10;    uint8_t uid[7];&#10;    uint8_t uidLength;&#10;&#10;    if (nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &amp;uidLength)) {&#10;        // Convert UID to string&#10;        String uidString = &quot;&quot;;&#10;        for (uint8_t i = 0; i &lt; uidLength; i++) {&#10;            if (uid[i] &lt; 0x10) uidString += &quot;0&quot;;&#10;            uidString += String(uid[i], HEX);&#10;        }&#10;        uidString.toUpperCase();&#10;&#10;        // Check for debounce - prevent same card from being processed too quickly&#10;        if (uidString == lastScannedUID &amp;&amp; (millis() - lastScanTime &lt; SCAN_DEBOUNCE_TIME)) {&#10;            return; // Ignore duplicate scan within debounce time&#10;        }&#10;&#10;        Serial.print(&quot;Driver RFID scanned: &quot;);&#10;        Serial.println(uidString);&#10;&#10;        // Update debounce variables&#10;        lastScannedUID = uidString;&#10;        lastScanTime = millis();&#10;        isProcessingRFID = true;&#10;&#10;        // Check driver registration in database&#10;        checkDriverRegistration(uidString);&#10;    }&#10;}&#10;&#10;void checkDriverRegistration(String rfidUID) {&#10;    Serial.println(&quot;Checking driver registration using RFID index...&quot;);&#10;    Serial.println(&quot;Looking up RFID: &quot; + rfidUID);&#10;&#10;    fbdo.clear();&#10;&#10;    // Step 1: Use the new rfidUIDIndex for instant driver ID lookup&#10;    String indexPath = &quot;/rfidUIDIndex/&quot; + rfidUID;&#10;&#10;    if (Firebase.RTDB.getString(&amp;fbdo, indexPath)) {&#10;        String driverId = fbdo.stringData();&#10;&#10;        if (driverId.length() == 0 || driverId == &quot;null&quot;) {&#10;            Serial.println(&quot;✗ RFID not found in index: &quot; + rfidUID);&#10;            showError(&quot;RFID not registered. Please register driver first.&quot;);&#10;            delay(2000);&#10;            isProcessingRFID = false;&#10;            return;&#10;        }&#10;&#10;        Serial.println(&quot;✓ Driver ID found in index: &quot; + driverId);&#10;&#10;        // Step 2: Fetch the full driver data using the driver ID&#10;        String driverPath = &quot;/drivers/&quot; + driverId;&#10;        FirebaseData fbdo2; // Use separate FirebaseData object&#10;&#10;        if (Firebase.RTDB.get(&amp;fbdo2, driverPath)) {&#10;            if (fbdo2.dataType() == &quot;json&quot;) {&#10;                String driverJson = fbdo2.jsonString();&#10;&#10;                // Parse essential driver fields&#10;                int nameStart = driverJson.indexOf(&quot;\&quot;driverName\&quot;:\&quot;&quot;) + 14;&#10;                int nameEnd = (nameStart &gt;= 14) ? driverJson.indexOf(&quot;\&quot;&quot;, nameStart) : -1;&#10;                String driverName = (nameStart &gt;= 14 &amp;&amp; nameEnd &gt; nameStart) ? driverJson.substring(nameStart, nameEnd) : &quot;&quot;;&#10;&#10;                int todaStart = driverJson.indexOf(&quot;\&quot;todaNumber\&quot;:\&quot;&quot;) + 14;&#10;                int todaEnd = (todaStart &gt;= 14) ? driverJson.indexOf(&quot;\&quot;&quot;, todaStart) : -1;&#10;                String todaNumber = (todaStart &gt;= 14 &amp;&amp; todaEnd &gt; todaStart) ? driverJson.substring(todaStart, todaEnd) : &quot;&quot;;&#10;&#10;                // Check if driver is active&#10;                bool isActive = true;&#10;                int activePos = driverJson.indexOf(&quot;\&quot;isActive\&quot;:&quot;);&#10;                if (activePos != -1) {&#10;                    int vStart = activePos + 11;&#10;                    String v = driverJson.substring(vStart, min((int)driverJson.length(), vStart + 5));&#10;                    v.trim();&#10;                    isActive = v.startsWith(&quot;true&quot;);&#10;                }&#10;&#10;                // New: parse paymentMode (default to pay_every_trip)&#10;                String paymentMode = &quot;pay_every_trip&quot;;&#10;                int pmPos = driverJson.indexOf(&quot;\&quot;paymentMode\&quot;:\&quot;&quot;);&#10;                if (pmPos != -1) {&#10;                    int pmStart = pmPos + 15;&#10;                    int pmEnd = driverJson.indexOf(&quot;\&quot;&quot;, pmStart);&#10;                    if (pmEnd &gt; pmStart) {&#10;                        paymentMode = driverJson.substring(pmStart, pmEnd);&#10;                    }&#10;                }&#10;&#10;                if (!isActive) {&#10;                    Serial.println(&quot;✗ Driver is inactive&quot;);&#10;                    showError(&quot;Driver account inactive. Please contact admin.&quot;);&#10;                    delay(2000);&#10;                    isProcessingRFID = false;&#10;                    return;&#10;                }&#10;&#10;                if (driverName.length() &gt; 0 &amp;&amp; todaNumber.length() &gt; 0) {&#10;                    Driver driver;&#10;                    driver.rfidUID = rfidUID;&#10;                    driver.driverName = driverName;&#10;                    driver.todaNumber = todaNumber;&#10;                    driver.isRegistered = true;&#10;                    driver.driverId = driverId; // New&#10;                    driver.paymentMode = paymentMode; // New&#10;&#10;                    Serial.println(&quot;✓ Driver found via RFID index:&quot;);&#10;                    Serial.println(&quot;  Driver ID: &quot; + driverId);&#10;                    Serial.println(&quot;  Name: &quot; + driver.driverName);&#10;                    Serial.println(&quot;  TODA Number: &quot; + driver.todaNumber);&#10;                    Serial.println(&quot;  Payment Mode: &quot; + driver.paymentMode);&#10;&#10;                    // Branch by payment mode&#10;                    if (driver.paymentMode == &quot;pay_later&quot;) {&#10;                        Serial.println(&quot;Payment mode is PAY LATER - will queue without coin and increment balance.&quot;);&#10;                        processPayLaterAndQueue(driver);&#10;                        isProcessingRFID = false;&#10;                        return;&#10;                    } else {&#10;                        enableCoinSlot(driver);&#10;                        delay(1000);&#10;                        isProcessingRFID = false;&#10;                        return;&#10;                    }&#10;                } else {&#10;                    Serial.println(&quot;✗ Incomplete driver data&quot;);&#10;                    showError(&quot;Driver record incomplete. Please contact admin.&quot;);&#10;                    delay(2000);&#10;                    isProcessingRFID = false;&#10;                    return;&#10;                }&#10;            } else {&#10;                Serial.println(&quot;✗ Driver data is not JSON: &quot; + fbdo2.dataType());&#10;                showError(&quot;Invalid driver data format. Please contact admin.&quot;);&#10;                delay(2000);&#10;                isProcessingRFID = false;&#10;                return;&#10;            }&#10;        } else {&#10;            Serial.println(&quot;✗ Failed to fetch driver data: &quot; + fbdo2.errorReason());&#10;            showError(&quot;Failed to read driver data. Please try again.&quot;);&#10;            delay(2000);&#10;            isProcessingRFID = false;&#10;            return;&#10;        }&#10;    } else {&#10;        String error = fbdo.errorReason();&#10;        Serial.println(&quot;✗ Failed to lookup RFID index: &quot; + error);&#10;&#10;        // Check if it's a &quot;not found&quot; error vs connection error&#10;        if (error.indexOf(&quot;not exist&quot;) != -1 || error.indexOf(&quot;null&quot;) != -1) {&#10;            showError(&quot;RFID not registered. Please register driver first.&quot;);&#10;        } else {&#10;            showError(&quot;Database connection error. Check WiFi.&quot;);&#10;        }&#10;        delay(2000);&#10;        isProcessingRFID = false;&#10;        return;&#10;    }&#10;}&#10;&#10;&#10;void enableCoinSlot(Driver driver) {&#10;    Serial.println(&quot;\n=== ENABLING COIN SLOT ===&quot;);&#10;&#10;    // FIRST: Check if driver is already in queue before enabling coin slot&#10;    Serial.println(&quot;Checking if driver is already in queue before enabling coin slot...&quot;);&#10;&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#10;            String queueJson = fbdo.jsonString();&#10;&#10;            // Check if this driver's RFID is already in the queue with &quot;waiting&quot; status&#10;            String searchPattern = &quot;\&quot;driverRFID\&quot;:\&quot;&quot; + driver.rfidUID + &quot;\&quot;&quot;;&#10;            int rfidPos = queueJson.indexOf(searchPattern);&#10;&#10;            if (rfidPos != -1) {&#10;                // Found the driver's RFID, now check if they have &quot;waiting&quot; status&#10;                int statusStart = queueJson.indexOf(&quot;\&quot;status\&quot;:&quot;, rfidPos);&#10;                if (statusStart != -1) {&#10;                    int statusValueStart = queueJson.indexOf(&quot;\&quot;&quot;, statusStart + 9) + 1;&#10;                    int statusValueEnd = queueJson.indexOf(&quot;\&quot;&quot;, statusValueStart);&#10;                    String status = queueJson.substring(statusValueStart, statusValueEnd);&#10;&#10;                    if (status == &quot;waiting&quot;) {&#10;                        Serial.println(&quot;✗ Driver &quot; + driver.driverName + &quot; is already in the queue!&quot;);&#10;                        Serial.println(&quot;Coin slot will NOT be enabled. Please wait for your turn.&quot;);&#10;                        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#10;&#10;                        // Display error on LCD&#10;                        updateLCDDisplay(driver.todaNumber, &quot;Already in Queue!&quot;);&#10;                        delay(3000); // Show error for 3 seconds&#10;                        clearLCDDisplay();&#10;&#10;                        // Reset processing flag and re-enable NFC immediately&#10;                        isProcessingRFID = false;&#10;                        nfcEnabled = true;&#10;                        coinSlotEnabled = false;&#10;                        return; // Exit without enabling coin slot&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Serial.println(&quot;Driver not in queue, proceeding to enable coin slot...&quot;);&#10;&#10;    // Disable NFC to prevent interference&#10;    nfcEnabled = false;&#10;    coinSlotEnabled = true;&#10;    isProcessingRFID = false; // Allow processing to continue&#10;&#10;    // Reset coin pulse counters and mark power-on time&#10;    noInterrupts();&#10;    coinValidPulses = 0;&#10;    coinActive = false;&#10;    interrupts();&#10;    coinSlotPowerOnTime = millis();&#10;&#10;    Serial.println(&quot;NFC disabled: &quot; + String(nfcEnabled ? &quot;false&quot; : &quot;true&quot;));&#10;    Serial.println(&quot;Coin slot enabled: &quot; + String(coinSlotEnabled ? &quot;true&quot; : &quot;false&quot;));&#10;&#10;    // Send command to Arduino to power on coin slot&#10;    Serial.println(&quot;Sending command 200 to Arduino via Serial2...&quot;);&#10;    Serial2.write((uint8_t)200);&#10;    Serial2.flush(); // Ensure data is sent&#10;&#10;    Serial.println(&quot;✓ Command sent to Arduino&quot;);&#10;    Serial.println(&quot;RFID verified! PN532 disabled. Coin slot enabled - insert ₱&quot; + String(CONTRIBUTION_AMOUNT) + &quot; contribution.&quot;);&#10;    Serial.println(&quot;Driver: &quot; + driver.driverName + &quot; (TODA #&quot; + driver.todaNumber + &quot;)&quot;);&#10;&#10;    // Store current driver info for contribution processing&#10;    currentDriver = driver;&#10;&#10;    // Display on LCD: TODA-001 INSERT X&#10;    updateLCDDisplay(driver.todaNumber, &quot;INSERT &quot; + String(CONTRIBUTION_AMOUNT));&#10;&#10;    Serial.println(&quot;=== COIN SLOT READY ===\n&quot;);&#10;}&#10;&#10;void processCoinContribution() {&#10;    totalSavings += CONTRIBUTION_AMOUNT;&#10;    Serial.println(&quot;₱&quot; + String(CONTRIBUTION_AMOUNT) + &quot; contribution received from &quot; + currentDriver.driverName);&#10;    Serial.println(&quot;Total today: ₱&quot; + String(totalSavings));&#10;&#10;    // Display success message on LCD&#10;    updateLCDDisplay(currentDriver.todaNumber, &quot;Payment Success!&quot;);&#10;    delay(2000); // Show success message for 2 seconds&#10;&#10;    // Send command to Arduino to power off coin slot&#10;    Serial2.write((uint8_t)201);&#10;    Serial2.flush();&#10;&#10;    // Process contribution and add to queue&#10;    processContributionAndQueue();&#10;&#10;    // Re-enable NFC for next driver&#10;    coinSlotEnabled = false;&#10;    nfcEnabled = true;&#10;    isProcessingRFID = false; // Make sure RFID processing flag is cleared&#10;&#10;    // Clear coin pulses to avoid re-trigger&#10;    noInterrupts();&#10;    coinValidPulses = 0;&#10;    coinActive = false;&#10;    interrupts();&#10;&#10;    // Clear LCD and show system ready message&#10;    clearLCDDisplay();&#10;&#10;    Serial.println(&quot;Contribution processed! PN532 re-enabled. Next driver can scan RFID.&quot;);&#10;    Serial.println(&quot;System ready for next driver...&quot;);&#10;}&#10;&#10;void processContributionAndQueue() {&#10;    Serial.println(&quot;Processing contribution and adding to queue...&quot;);&#10;&#10;    // Record contribution in database&#10;    recordContribution();&#10;&#10;    // Add driver to queue&#10;    addDriverToQueue();&#10;}&#10;&#10;void recordContribution() {&#10;    // Create contribution record JSON&#10;    String timestamp = String(time(nullptr));&#10;    String contributionPath = &quot;/contributions/&quot; + timestamp;&#10;&#10;    FirebaseJson contributionJson;&#10;    contributionJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#10;    contributionJson.set(&quot;driverName&quot;, currentDriver.driverName);&#10;    contributionJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#10;    contributionJson.set(&quot;amount&quot;, CONTRIBUTION_AMOUNT);&#10;    contributionJson.set(&quot;timestamp&quot;, timestamp);&#10;    contributionJson.set(&quot;date&quot;, getCurrentDate());&#10;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, contributionPath, &amp;contributionJson)) {&#10;        Serial.println(&quot;✓ Contribution recorded in database&quot;);&#10;    } else {&#10;        Serial.println(&quot;✗ Failed to record contribution: &quot; + fbdo.errorReason());&#10;    }&#10;}&#10;&#10;// New: process pay-later flow&#10;void processPayLaterAndQueue(Driver driver) {&#10;    Serial.println(&quot;\n=== PAY LATER FLOW ===&quot;);&#10;&#10;    // Check duplicate in queue first&#10;    Serial.println(&quot;Checking if driver is already in queue (pay_later)...&quot;);&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#10;            String queueJson = fbdo.jsonString();&#10;            String searchPattern = &quot;\&quot;driverRFID\&quot;:\&quot;&quot; + driver.rfidUID + &quot;\&quot;&quot;;&#10;            int rfidPos = queueJson.indexOf(searchPattern);&#10;            if (rfidPos != -1) {&#10;                int statusStart = queueJson.indexOf(&quot;\&quot;status\&quot;:&quot;, rfidPos);&#10;                if (statusStart != -1) {&#10;                    int statusValueStart = queueJson.indexOf(&quot;\&quot;&quot;, statusStart + 9) + 1;&#10;                    int statusValueEnd = queueJson.indexOf(&quot;\&quot;&quot;, statusValueStart);&#10;                    String status = queueJson.substring(statusValueStart, statusValueEnd);&#10;                    if (status == &quot;waiting&quot;) {&#10;                        Serial.println(&quot;✗ Driver &quot; + driver.driverName + &quot; is already in the queue!&quot;);&#10;                        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#10;                        updateLCDDisplay(driver.todaNumber, &quot;Already in Queue!&quot;);&#10;                        delay(3000);&#10;                        clearLCDDisplay();&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Increment driver's balance by contribution amount&#10;    String balancePath = &quot;/drivers/&quot; + driver.driverId + &quot;/balance&quot;;&#10;    long currentBalance = 0;&#10;    bool gotBalance = false;&#10;    if (Firebase.RTDB.getInt(&amp;fbdo, balancePath)) {&#10;        currentBalance = fbdo.intData();&#10;        gotBalance = true;&#10;    } else {&#10;        String err = fbdo.errorReason();&#10;        // If path not exist, treat as zero&#10;        if (err.indexOf(&quot;not exist&quot;) != -1 || fbdo.httpCode() == 404) {&#10;            currentBalance = 0;&#10;            gotBalance = true;&#10;        } else {&#10;            // Fallback: try reading as string and parse&#10;            FirebaseData fbdoStr;&#10;            if (Firebase.RTDB.getString(&amp;fbdoStr, balancePath)) {&#10;                String balStr = fbdoStr.stringData();&#10;                balStr.trim();&#10;                currentBalance = balStr.toInt();&#10;                gotBalance = true;&#10;                Serial.println(&quot;Balance read as string: '&quot; + balStr + &quot;' -&gt; &quot; + String(currentBalance));&#10;            } else {&#10;                Serial.println(&quot;✗ Failed to read balance: &quot; + err);&#10;            }&#10;        }&#10;    }&#10;&#10;    if (gotBalance) {&#10;        long newBalance = currentBalance + CONTRIBUTION_AMOUNT;&#10;        if (Firebase.RTDB.setInt(&amp;fbdo, balancePath, newBalance)) {&#10;            Serial.println(&quot;✓ Balance updated: &quot; + String(currentBalance) + &quot; -&gt; &quot; + String(newBalance));&#10;        } else {&#10;            Serial.println(&quot;✗ Failed to update balance: &quot; + fbdo.errorReason());&#10;            showError(&quot;Failed to update balance. Try again.&quot;);&#10;            return;&#10;        }&#10;    } else {&#10;        showError(&quot;Unable to read current balance.&quot;);&#10;        return;&#10;    }&#10;&#10;    // Set current driver and add to queue with contributionPaid=false&#10;    currentDriver = driver;&#10;    addDriverToQueueWithPaid(false);&#10;&#10;    // Keep NFC ON, coin slot OFF&#10;    coinSlotEnabled = false;&#10;    nfcEnabled = true;&#10;&#10;    // Show LCD message (fit 16 chars)&#10;    updateLCDDisplay(driver.todaNumber, &quot;Queued PayLater&quot;);&#10;    delay(2000);&#10;    clearLCDDisplay();&#10;&#10;    Serial.println(&quot;Pay-later processing completed. Driver queued without coin.&quot;);&#10;}&#10;&#10;void addDriverToQueue() {&#10;    Serial.println(&quot;Checking if driver is already in queue...&quot;);&#10;&#10;    // First, check if driver is already in the queue&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#10;            String queueJson = fbdo.jsonString();&#10;&#10;            // Check if this driver's RFID is already in the queue with &quot;waiting&quot; status&#10;            String searchPattern = &quot;\&quot;driverRFID\&quot;:\&quot;&quot; + currentDriver.rfidUID + &quot;\&quot;&quot;;&#10;            int rfidPos = queueJson.indexOf(searchPattern);&#10;&#10;            if (rfidPos != -1) {&#10;                // Found the driver's RFID, now check if they have &quot;waiting&quot; status&#10;                int statusStart = queueJson.indexOf(&quot;\&quot;status\&quot;:&quot;, rfidPos);&#10;                if (statusStart != -1) {&#10;                    int statusValueStart = queueJson.indexOf(&quot;\&quot;&quot;, statusStart + 9) + 1;&#10;                    int statusValueEnd = queueJson.indexOf(&quot;\&quot;&quot;, statusValueStart);&#10;                    String status = queueJson.substring(statusValueStart, statusValueEnd);&#10;&#10;                    if (status == &quot;waiting&quot;) {&#10;                        Serial.println(&quot;✗ Driver &quot; + currentDriver.driverName + &quot; is already in the queue!&quot;);&#10;                        Serial.println(&quot;Please wait for your turn or check with the operator.&quot;);&#10;                        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#10;                        return; // Exit without adding to queue&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Serial.println(&quot;Driver not in queue, adding to queue...&quot;);&#10;&#10;    // Create queue entry JSON&#10;    String timestamp = String(time(nullptr));&#10;    String queuePath = &quot;/queue/&quot; + timestamp;&#10;&#10;    FirebaseJson queueJson;&#10;    queueJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#10;    queueJson.set(&quot;driverName&quot;, currentDriver.driverName);&#10;    queueJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#10;    queueJson.set(&quot;queueTime&quot;, timestamp);&#10;    queueJson.set(&quot;timestamp&quot;, getCurrentDate() + &quot; &quot; + getCurrentTime()); // Real-time readable timestamp&#10;    queueJson.set(&quot;status&quot;, &quot;waiting&quot;);&#10;    queueJson.set(&quot;contributionPaid&quot;, true);&#10;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, queuePath, &amp;queueJson)) {&#10;        Serial.println(&quot;✓ Driver added to queue successfully!&quot;);&#10;        Serial.println(&quot;Driver &quot; + currentDriver.driverName + &quot; is now in the tricycle queue&quot;);&#10;        Serial.println(&quot;Queue Time: &quot; + getCurrentDate() + &quot; &quot; + getCurrentTime());&#10;    } else {&#10;        Serial.println(&quot;✗ Failed to add driver to queue: &quot; + fbdo.errorReason());&#10;    }&#10;}&#10;&#10;// New: same as addDriverToQueue but configurable contributionPaid flag&#10;void addDriverToQueueWithPaid(bool paid) {&#10;    Serial.println(&quot;Adding driver to queue (paid=&quot; + String(paid ? &quot;true&quot; : &quot;false&quot;) + &quot;)...&quot;);&#10;&#10;    // Duplicate check similar to addDriverToQueue&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#10;            String queueJson = fbdo.jsonString();&#10;            String searchPattern = &quot;\&quot;driverRFID\&quot;:\&quot;&quot; + currentDriver.rfidUID + &quot;\&quot;&quot;;&#10;            int rfidPos = queueJson.indexOf(searchPattern);&#10;            if (rfidPos != -1) {&#10;                int statusStart = queueJson.indexOf(&quot;\&quot;status\&quot;:&quot;, rfidPos);&#10;                if (statusStart != -1) {&#10;                    int statusValueStart = queueJson.indexOf(&quot;\&quot;&quot;, statusStart + 9) + 1;&#10;                    int statusValueEnd = queueJson.indexOf(&quot;\&quot;&quot;, statusValueStart);&#10;                    String status = queueJson.substring(statusValueStart, statusValueEnd);&#10;                    if (status == &quot;waiting&quot;) {&#10;                        Serial.println(&quot;✗ Driver &quot; + currentDriver.driverName + &quot; is already in the queue!&quot;);&#10;                        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    String timestamp = String(time(nullptr));&#10;    String queuePath = &quot;/queue/&quot; + timestamp;&#10;&#10;    FirebaseJson queueJson;&#10;    queueJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#10;    queueJson.set(&quot;driverName&quot;, currentDriver.driverName);&#10;    queueJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#10;    queueJson.set(&quot;queueTime&quot;, timestamp);&#10;    queueJson.set(&quot;timestamp&quot;, getCurrentDate() + &quot; &quot; + getCurrentTime());&#10;    queueJson.set(&quot;status&quot;, &quot;waiting&quot;);&#10;    queueJson.set(&quot;contributionPaid&quot;, paid);&#10;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, queuePath, &amp;queueJson)) {&#10;        Serial.println(&quot;✓ Driver added to queue successfully (paid=&quot; + String(paid ? &quot;true&quot; : &quot;false&quot;) + &quot;)&quot;);&#10;    } else {&#10;        Serial.println(&quot;✗ Failed to add driver to queue: &quot; + fbdo.errorReason());&#10;    }&#10;}&#10;&#10;void showError(String message) {&#10;    Serial.println(&quot;ERROR: &quot; + message);&#10;    Serial.println(&quot;Please try scanning the RFID card again...&quot;);&#10;    // Here you could add LED indicators, buzzer, or display messages&#10;}&#10;&#10;String getCurrentDate() {&#10;    time_t now = time(nullptr);&#10;    struct tm* timeinfo = localtime(&amp;now);&#10;&#10;    char dateStr[11];&#10;    sprintf(dateStr, &quot;%04d-%02d-%02d&quot;,&#10;            timeinfo-&gt;tm_year + 1900,&#10;            timeinfo-&gt;tm_mon + 1,&#10;            timeinfo-&gt;tm_mday);&#10;&#10;    return String(dateStr);&#10;}&#10;&#10;String getCurrentTime() {&#10;    time_t now = time(nullptr);&#10;    struct tm* timeinfo = localtime(&amp;now);&#10;&#10;    char timeStr[9];&#10;    sprintf(timeStr, &quot;%02d:%02d:%02d&quot;,&#10;            timeinfo-&gt;tm_hour,&#10;            timeinfo-&gt;tm_min,&#10;            timeinfo-&gt;tm_sec);&#10;&#10;    return String(timeStr);&#10;}&#10;&#10;// LCD Display Functions&#10;void updateLCDDisplay(String todaNumber, String message) {&#10;    lcd.clear();&#10;    lcd.setCursor(0, 0);&#10;    lcd.print(&quot;TODA-&quot; + todaNumber);&#10;    lcd.setCursor(0, 1);&#10;    lcd.print(message);&#10;&#10;    Serial.println(&quot;LCD Display Updated:&quot;);&#10;    Serial.println(&quot;Line 1: TODA-&quot; + todaNumber);&#10;    Serial.println(&quot;Line 2: &quot; + message);&#10;}&#10;&#10;void clearLCDDisplay() {&#10;    lcd.clear();&#10;    lcd.setCursor(0, 0);&#10;    lcd.print(&quot;System Ready&quot;);&#10;    lcd.setCursor(0, 1);&#10;    lcd.print(&quot;Scan RFID Card&quot;);&#10;&#10;    Serial.println(&quot;LCD Display Cleared - Ready for next scan&quot;);&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;WiFi.h&gt;&#13;&#10;#include &lt;Firebase_ESP_Client.h&gt;&#13;&#10;#include &lt;addons/TokenHelper.h&gt;&#13;&#10;#include &lt;addons/RTDBHelper.h&gt;&#13;&#10;#include &lt;WiFiClientSecure.h&gt;&#13;&#10;#include &lt;time.h&gt;&#13;&#10;#include &lt;Wire.h&gt;&#13;&#10;#include &lt;SPI.h&gt;&#13;&#10;#include &lt;Adafruit_PN532.h&gt;&#13;&#10;#include &lt;LiquidCrystal_I2C.h&gt;&#13;&#10;&#13;&#10;// WiFi credentials&#13;&#10;#define WIFI_SSID &quot;George&quot;&#13;&#10;#define WIFI_PASSWORD &quot;Aixroch!092601&quot;&#13;&#10;&#13;&#10;// Firebase credentials&#13;&#10;#define API_KEY &quot;AIzaSyAbEJ8tzm5RIeXvKhlxZl71a_tBX4WmN4E&quot;&#13;&#10;#define DATABASE_URL &quot;https://toda-contribution-system-default-rtdb.asia-southeast1.firebasedatabase.app/&quot;&#13;&#10;#define USER_EMAIL &quot;test@example.com&quot;&#13;&#10;#define USER_PASSWORD &quot;test123456&quot;&#13;&#10;&#13;&#10;// I2C LCD configuration&#13;&#10;#define LCD_SDA 21&#13;&#10;#define LCD_SCL 22&#13;&#10;#define LCD_ADDRESS 0x27  // Common I2C address for LCD, may need to change to 0x3F&#13;&#10;&#13;&#10;// PN532 SPI configuration&#13;&#10;#define PN532_SCK  18&#13;&#10;#define PN532_MOSI 23&#13;&#10;#define PN532_SS   5&#13;&#10;#define PN532_MISO 19&#13;&#10;&#13;&#10;// Serial communication to Arduino (TX only)&#13;&#10;#define ARDUINO_TX 17&#13;&#10;&#13;&#10;// Coin pulse input pin (coin acceptor signal wire connected directly to ESP32)&#13;&#10;#define COIN_PULSE_PIN 32&#13;&#10;&#13;&#10;// New: Standardized contribution amount&#13;&#10;const int CONTRIBUTION_AMOUNT = 5;&#13;&#10;&#13;&#10;// Create instances&#13;&#10;Adafruit_PN532 nfc(PN532_SCK, PN532_MISO, PN532_MOSI, PN532_SS);&#13;&#10;LiquidCrystal_I2C lcd(LCD_ADDRESS, 16, 2);  // 16x2 LCD display&#13;&#10;&#13;&#10;// Firebase objects&#13;&#10;FirebaseData fbdo;&#13;&#10;FirebaseAuth auth;&#13;&#10;FirebaseConfig config;&#13;&#10;&#13;&#10;// System state&#13;&#10;bool coinSlotEnabled = false;&#13;&#10;bool nfcEnabled = true;&#13;&#10;unsigned long lastNFCCheck = 0;&#13;&#10;const unsigned long NFC_CHECK_INTERVAL = 100;&#13;&#10;unsigned long totalSavings = 0;&#13;&#10;&#13;&#10;// Coin pulse detection (direct on ESP32)&#13;&#10;volatile unsigned long coinLastPulseUs = 0;&#13;&#10;// Count only VALID pulses based on width&#13;&#10;volatile uint16_t coinValidPulses = 0;&#13;&#10;// Active level configuration: runtime-tunable (true = active LOW, false = active HIGH)&#13;&#10;volatile bool coinActiveLow = true;&#13;&#10;// Track active state to measure pulse width&#13;&#10;volatile bool coinActive = false;&#13;&#10;volatile unsigned long coinActiveStartUs = 0;&#13;&#10;volatile unsigned long lastValidPulseWidthUs = 0;&#13;&#10;volatile uint32_t coinRawEdges = 0; // counts all CHANGE edges for diagnostics&#13;&#10;&#13;&#10;// Timing thresholds (runtime-tunable)&#13;&#10;volatile unsigned long coinGapUs = 350000UL;            // end of burst when quiet &gt; 350ms&#13;&#10;volatile unsigned long coinPowerStabilizeMs = 4000UL;   // wait 4s after power on&#13;&#10;volatile unsigned long minPulseUs = 2000UL;             // min active width = 2ms (filter spikes)&#13;&#10;volatile unsigned long maxPulseUs = 200000UL;           // max active width = 200ms (filter long noise)&#13;&#10;volatile uint8_t minBurstPulses = 1;                    // require N valid pulses before accepting a coin&#13;&#10;unsigned long coinSlotPowerOnTime = 0;&#13;&#10;&#13;&#10;// Add RFID debounce variables&#13;&#10;String lastScannedUID = &quot;&quot;;&#13;&#10;unsigned long lastScanTime = 0;&#13;&#10;const unsigned long SCAN_DEBOUNCE_TIME = 3000; // 3 seconds between same card scans&#13;&#10;bool isProcessingRFID = false;&#13;&#10;&#13;&#10;// Add Firebase timeout variables&#13;&#10;unsigned long firebaseTimeout = 10000; // 10 seconds timeout&#13;&#10;&#13;&#10;// Driver information structure&#13;&#10;struct Driver {&#13;&#10;    String rfidUID;&#13;&#10;    String todaNumber;&#13;&#10;    String driverName;&#13;&#10;    bool isRegistered;&#13;&#10;    // New fields&#13;&#10;    String driverId;&#13;&#10;    String paymentMode; // &quot;pay_every_trip&quot; or &quot;pay_later&quot;&#13;&#10;};&#13;&#10;&#13;&#10;// Global variable to store current driver info&#13;&#10;Driver currentDriver;&#13;&#10;&#13;&#10;// Queue management&#13;&#10;String firstDriverQueueKey = &quot;&quot;;&#13;&#10;&#13;&#10;// Function forward declarations&#13;&#10;void checkForRFIDCard();&#13;&#10;void checkDriverRegistration(String rfidUID);&#13;&#10;void enableCoinSlot(Driver driver);&#13;&#10;void processCoinContribution();&#13;&#10;void processContributionAndQueue();&#13;&#10;void recordContribution();&#13;&#10;void addDriverToQueue();&#13;&#10;// New forward declarations&#13;&#10;void processPayLaterAndQueue(Driver driver);&#13;&#10;void addDriverToQueueWithPaid(bool paid);&#13;&#10;void showError(String message);&#13;&#10;void updateLCDDisplay(String todaNumber, String message);&#13;&#10;void clearLCDDisplay();&#13;&#10;String getCurrentDate();&#13;&#10;String getCurrentTime();&#13;&#10;&#13;&#10;// ISR for coin pulse&#13;&#10;void IRAM_ATTR coinISR() {&#13;&#10;    int level = digitalRead(COIN_PULSE_PIN);&#13;&#10;    unsigned long nowUs = micros();&#13;&#10;&#13;&#10;    coinRawEdges++;&#13;&#10;&#13;&#10;    bool isActive = coinActiveLow ? (level == LOW) : (level == HIGH);&#13;&#10;&#13;&#10;    if (isActive) {&#13;&#10;        if (!coinActive) {&#13;&#10;            coinActive = true;&#13;&#10;            coinActiveStartUs = nowUs;&#13;&#10;        }&#13;&#10;    } else { // inactive edge&#13;&#10;        if (coinActive) {&#13;&#10;            unsigned long width = nowUs - coinActiveStartUs;&#13;&#10;            coinActive = false;&#13;&#10;            // Validate pulse width&#13;&#10;            if (width &gt;= minPulseUs &amp;&amp; width &lt;= maxPulseUs) {&#13;&#10;                coinValidPulses++;&#13;&#10;                coinLastPulseUs = nowUs;&#13;&#10;                lastValidPulseWidthUs = width;&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;void setup() {&#13;&#10;    Serial.begin(115200);&#13;&#10;    // Initialize Serial2 as TX-only (rxPin = -1) to command Arduino, no RX wire connected&#13;&#10;    Serial2.begin(9600, SERIAL_8N1, -1, ARDUINO_TX);&#13;&#10;&#13;&#10;    // Initialize coin pulse input&#13;&#10;    pinMode(COIN_PULSE_PIN, INPUT_PULLUP);&#13;&#10;    // Use CHANGE to measure pulse width accurately&#13;&#10;    attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#13;&#10;&#13;&#10;    // Initialize I2C for LCD with custom pins&#13;&#10;    Wire.begin(LCD_SDA, LCD_SCL);&#13;&#10;&#13;&#10;    // Initialize LCD&#13;&#10;    lcd.init();&#13;&#10;    lcd.backlight();&#13;&#10;    lcd.clear();&#13;&#10;&#13;&#10;    // Display startup message&#13;&#10;    lcd.setCursor(0, 0);&#13;&#10;    lcd.print(&quot;TODA System&quot;);&#13;&#10;    lcd.setCursor(0, 1);&#13;&#10;    lcd.print(&quot;Starting...&quot;);&#13;&#10;&#13;&#10;    Serial.println(&quot;ESP32 ready: TODA Contribution &amp; Queueing System&quot;);&#13;&#10;    Serial.println(&quot;Serial2 initialized: TX=17 (TX-only, no RX)&quot;);&#13;&#10;    Serial.print(&quot;LCD initialized: SDA=Pin&quot;);&#13;&#10;    Serial.print(LCD_SDA);&#13;&#10;    Serial.print(&quot;, SCL=Pin&quot;);&#13;&#10;    Serial.println(LCD_SCL);&#13;&#10;    Serial.println(&quot;Coin pulse input on pin 16 with interrupt (CHANGE)&quot;);&#13;&#10;    Serial.print(&quot;Coin polarity: active-&quot;);&#13;&#10;    Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#13;&#10;&#13;&#10;    // Initialize WiFi&#13;&#10;    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);&#13;&#10;    Serial.print(&quot;Connecting to WiFi&quot;);&#13;&#10;    while (WiFi.status() != WL_CONNECTED) {&#13;&#10;        delay(300);&#13;&#10;        Serial.print(&quot;.&quot;);&#13;&#10;    }&#13;&#10;    Serial.println();&#13;&#10;    Serial.print(&quot;Connected with IP: &quot;);&#13;&#10;    Serial.println(WiFi.localIP());&#13;&#10;&#13;&#10;    // Configure time (needed for Firebase)&#13;&#10;    configTime(8 * 3600, 0, &quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);  // GMT+8 Philippines&#13;&#10;&#13;&#10;    // Wait for time to be set&#13;&#10;    Serial.print(&quot;Waiting for NTP time sync&quot;);&#13;&#10;    time_t now = time(nullptr);&#13;&#10;    while (now &lt; 8 * 3600 * 2) {&#13;&#10;        delay(500);&#13;&#10;        Serial.print(&quot;.&quot;);&#13;&#10;        now = time(nullptr);&#13;&#10;    }&#13;&#10;    Serial.println();&#13;&#10;    Serial.println(&quot;Time synchronized&quot;);&#13;&#10;&#13;&#10;    // Initialize Firebase&#13;&#10;    config.api_key = API_KEY;&#13;&#10;    config.database_url = DATABASE_URL;&#13;&#10;&#13;&#10;    // Use email/password authentication&#13;&#10;    Serial.println(&quot;Initializing Firebase with email authentication...&quot;);&#13;&#10;&#13;&#10;    // Set user credentials&#13;&#10;    auth.user.email = USER_EMAIL;&#13;&#10;    auth.user.password = USER_PASSWORD;&#13;&#10;&#13;&#10;    // Assign the callback function for the long running token generation task&#13;&#10;    config.token_status_callback = tokenStatusCallback;&#13;&#10;&#13;&#10;    Firebase.begin(&amp;config, &amp;auth);&#13;&#10;    Firebase.reconnectWiFi(true);&#13;&#10;&#13;&#10;    // Set timeout&#13;&#10;    fbdo.setResponseSize(4096);&#13;&#10;&#13;&#10;    Serial.println(&quot;Firebase configuration complete&quot;);&#13;&#10;&#13;&#10;    // Wait for Firebase authentication&#13;&#10;    Serial.print(&quot;Waiting for Firebase authentication&quot;);&#13;&#10;    unsigned long startTime = millis();&#13;&#10;    while (!Firebase.ready() &amp;&amp; (millis() - startTime &lt; 30000)) {&#13;&#10;        delay(1000);&#13;&#10;        Serial.print(&quot;.&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    if (Firebase.ready()) {&#13;&#10;        Serial.println();&#13;&#10;        Serial.println(&quot;✓ Firebase authenticated and ready!&quot;);&#13;&#10;&#13;&#10;        // Test database connection&#13;&#10;        if (Firebase.RTDB.get(&amp;fbdo, &quot;/drivers&quot;)) {&#13;&#10;            Serial.println(&quot;✓ Database connection successful!&quot;);&#13;&#10;        } else {&#13;&#10;            Serial.println(&quot;Database test result: &quot; + fbdo.errorReason());&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        Serial.println();&#13;&#10;        Serial.println(&quot;✗ Firebase authentication failed&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Initialize PN532&#13;&#10;    nfc.begin();&#13;&#10;    uint32_t versiondata = nfc.getFirmwareVersion();&#13;&#10;    if (!versiondata) {&#13;&#10;        Serial.println(&quot;PN532 not found&quot;);&#13;&#10;    } else {&#13;&#10;        Serial.print(&quot;Found PN532 with firmware version: &quot;);&#13;&#10;        Serial.println((versiondata &gt;&gt; 16) &amp; 0xFF, HEX);&#13;&#10;        nfc.SAMConfig();&#13;&#10;        Serial.println(&quot;PN532 ready, waiting for driver RFID...&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    Serial.println(&quot;System ready: Please scan driver RFID card to start contribution process&quot;);&#13;&#10;&#13;&#10;    // Update LCD with system ready message&#13;&#10;    lcd.clear();&#13;&#10;    lcd.setCursor(0, 0);&#13;&#10;    lcd.print(&quot;System Ready&quot;);&#13;&#10;    lcd.setCursor(0, 1);&#13;&#10;    lcd.print(&quot;Scan RFID Card&quot;);&#13;&#10;}&#13;&#10;&#13;&#10;void loop() {&#13;&#10;    // DIRECT COIN PULSE HANDLING (no Serial2 RX)&#13;&#10;    if (coinSlotEnabled) {&#13;&#10;        // Check if a pulse burst has finished&#13;&#10;        noInterrupts();&#13;&#10;        uint16_t pulses = coinValidPulses;&#13;&#10;        unsigned long lastUs = coinLastPulseUs;&#13;&#10;        bool activeNow = coinActive;&#13;&#10;        unsigned long lastWidth = lastValidPulseWidthUs;&#13;&#10;        interrupts();&#13;&#10;&#13;&#10;        // Only act after initial power stabilization&#13;&#10;        if (millis() - coinSlotPowerOnTime &lt; coinPowerStabilizeMs) {&#13;&#10;            // Clear any early pulses as noise during stabilization&#13;&#10;            if (pulses &gt; 0 || activeNow) {&#13;&#10;                noInterrupts();&#13;&#10;                coinValidPulses = 0;&#13;&#10;                coinActive = false;&#13;&#10;                interrupts();&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            // When we have a sufficient number of valid pulses and quiet period, process&#13;&#10;            if (pulses &gt;= minBurstPulses &amp;&amp; (micros() - lastUs &gt; coinGapUs) &amp;&amp; !activeNow) {&#13;&#10;                Serial.print(&quot;Coin burst validated - pulses: &quot;);&#13;&#10;                Serial.print(pulses);&#13;&#10;                Serial.print(&quot;, last width(us): &quot;);&#13;&#10;                Serial.println(lastWidth);&#13;&#10;&#13;&#10;                // Reset counters before processing to avoid re-entry&#13;&#10;                noInterrupts();&#13;&#10;                coinValidPulses = 0;&#13;&#10;                coinActive = false;&#13;&#10;                interrupts();&#13;&#10;&#13;&#10;                processCoinContribution();&#13;&#10;            }&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        // If disabled, clear any accumulated pulses silently&#13;&#10;        if (coinValidPulses &gt; 0 || coinActive) {&#13;&#10;            noInterrupts();&#13;&#10;            coinValidPulses = 0;&#13;&#10;            coinActive = false;&#13;&#10;            interrupts();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Check for NFC cards (only when enabled)&#13;&#10;    if (nfcEnabled &amp;&amp; (millis() - lastNFCCheck &gt;= NFC_CHECK_INTERVAL)) {&#13;&#10;        lastNFCCheck = millis();&#13;&#10;        checkForRFIDCard();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Debug system status every 10 seconds&#13;&#10;    static unsigned long lastSystemStatus = 0;&#13;&#10;    if (millis() - lastSystemStatus &gt; 10000) {&#13;&#10;        Serial.println(&quot;System Status - NFC: &quot; + String(nfcEnabled ? &quot;ON&quot; : &quot;OFF&quot;) +&#13;&#10;                       &quot;, CoinSlot: &quot; + String(coinSlotEnabled ? &quot;ON&quot; : &quot;OFF&quot;) +&#13;&#10;                       &quot;, ProcessingRFID: &quot; + String(isProcessingRFID ? &quot;YES&quot; : &quot;NO&quot;));&#13;&#10;        lastSystemStatus = millis();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Check for manual commands via Serial Monitor (for debugging)&#13;&#10;    if (Serial.available()) {&#13;&#10;        String command = Serial.readString();&#13;&#10;        command.trim();&#13;&#10;        command.toLowerCase();&#13;&#10;&#13;&#10;        if (command == &quot;enable&quot;) {&#13;&#10;            Serial.println(&quot;Manually enabling coin slot...&quot;);&#13;&#10;            Driver testDriver;&#13;&#10;            testDriver.rfidUID = &quot;MANUAL&quot;;&#13;&#10;            testDriver.driverName = &quot;Manual Test&quot;;&#13;&#10;            testDriver.todaNumber = &quot;TEST&quot;;&#13;&#10;            testDriver.isRegistered = true;&#13;&#10;            enableCoinSlot(testDriver);&#13;&#10;        } else if (command == &quot;disable&quot;) {&#13;&#10;            Serial.println(&quot;Manually disabling coin slot...&quot;);&#13;&#10;            coinSlotEnabled = false;&#13;&#10;            nfcEnabled = true;&#13;&#10;            Serial2.write((uint8_t)201);&#13;&#10;            Serial2.flush();&#13;&#10;            // Clear any pending coin pulses&#13;&#10;            noInterrupts();&#13;&#10;            coinValidPulses = 0;&#13;&#10;            coinActive = false;&#13;&#10;            interrupts();&#13;&#10;            Serial.println(&quot;Coin slot disabled, NFC re-enabled&quot;);&#13;&#10;        } else if (command == &quot;status&quot;) {&#13;&#10;            Serial.println(&quot;\n=== SYSTEM STATUS ===&quot;);&#13;&#10;            Serial.println(&quot;NFC Enabled: &quot; + String(nfcEnabled ? &quot;true&quot; : &quot;false&quot;));&#13;&#10;            Serial.println(&quot;Coin Slot Enabled: &quot; + String(coinSlotEnabled ? &quot;true&quot; : &quot;false&quot;));&#13;&#10;            Serial.println(&quot;Processing RFID: &quot; + String(isProcessingRFID ? &quot;true&quot; : &quot;false&quot;));&#13;&#10;            Serial.println(&quot;WiFi Status: &quot; + String(WiFi.status() == WL_CONNECTED ? &quot;Connected&quot; : &quot;Disconnected&quot;));&#13;&#10;            Serial.println(&quot;Firebase Ready: &quot; + String(Firebase.ready() ? &quot;true&quot; : &quot;false&quot;));&#13;&#10;            Serial.println(&quot;==================&quot;);&#13;&#10;        } else if (command == &quot;test200&quot;) {&#13;&#10;            Serial.println(&quot;Sending command 200 to Arduino...&quot;);&#13;&#10;            Serial2.write((uint8_t)200);&#13;&#10;            Serial2.flush();&#13;&#10;            Serial.println(&quot;Command 200 sent!&quot;);&#13;&#10;        } else if (command == &quot;test201&quot;) {&#13;&#10;            Serial.println(&quot;Sending command 201 to Arduino...&quot;);&#13;&#10;            Serial2.write((uint8_t)201);&#13;&#10;            Serial2.flush();&#13;&#10;            Serial.println(&quot;Command 201 sent!&quot;);&#13;&#10;        } else if (command == &quot;queue&quot;) {&#13;&#10;            Serial.println(&quot;Checking driver queue status...&quot;);&#13;&#10;            checkQueueStatus();&#13;&#10;&#13;&#10;        } else if (command.startsWith(&quot;coinpol&quot;)) {&#13;&#10;            if (command.indexOf(&quot;high&quot;) != -1) {&#13;&#10;                coinActiveLow = false;&#13;&#10;                Serial.println(&quot;Coin polarity set to ACTIVE-HIGH&quot;);&#13;&#10;            } else if (command.indexOf(&quot;low&quot;) != -1) {&#13;&#10;                coinActiveLow = true;&#13;&#10;                Serial.println(&quot;Coin polarity set to ACTIVE-LOW&quot;);&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;Usage: coinpol low|high&quot;);&#13;&#10;            }&#13;&#10;        } else if (command == &quot;coinstat&quot;) {&#13;&#10;            noInterrupts();&#13;&#10;            uint16_t pulses = coinValidPulses;&#13;&#10;            bool activeNow = coinActive;&#13;&#10;            unsigned long lastWidth = lastValidPulseWidthUs;&#13;&#10;            uint32_t edges = coinRawEdges;&#13;&#10;            int pinLevel = digitalRead(COIN_PULSE_PIN);&#13;&#10;            interrupts();&#13;&#10;            Serial.println(&quot;=== COIN INPUT STATUS ===&quot;);&#13;&#10;            Serial.print(&quot;Polarity: ACTIVE-&quot;); Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#13;&#10;            Serial.print(&quot;Pin level: &quot;); Serial.println(pinLevel == HIGH ? &quot;HIGH&quot; : &quot;LOW&quot;);&#13;&#10;            Serial.print(&quot;Valid pulses (since enable): &quot;); Serial.println(pulses);&#13;&#10;            Serial.print(&quot;Raw edges (since boot): &quot;); Serial.println(edges);&#13;&#10;            Serial.print(&quot;Last valid pulse width (us): &quot;); Serial.println(lastWidth);&#13;&#10;            Serial.print(&quot;Active now: &quot;); Serial.println(activeNow ? &quot;YES&quot; : &quot;NO&quot;);&#13;&#10;            Serial.print(&quot;Millis since power-on of slot: &quot;); Serial.println(millis() - coinSlotPowerOnTime);&#13;&#10;            Serial.println(&quot;=========================&quot;);&#13;&#10;        } else if (command.startsWith(&quot;coinpull&quot;)) {&#13;&#10;            if (command.indexOf(&quot;up&quot;) != -1) {&#13;&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#13;&#10;                pinMode(COIN_PULSE_PIN, INPUT_PULLUP);&#13;&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#13;&#10;                Serial.println(&quot;Coin pin mode: INPUT_PULLUP&quot;);&#13;&#10;            } else if (command.indexOf(&quot;down&quot;) != -1) {&#13;&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#13;&#10;                pinMode(COIN_PULSE_PIN, INPUT_PULLDOWN);&#13;&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#13;&#10;                Serial.println(&quot;Coin pin mode: INPUT_PULLDOWN&quot;);&#13;&#10;            } else if (command.indexOf(&quot;float&quot;) != -1) {&#13;&#10;                detachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN));&#13;&#10;                pinMode(COIN_PULSE_PIN, INPUT);&#13;&#10;                attachInterrupt(digitalPinToInterrupt(COIN_PULSE_PIN), coinISR, CHANGE);&#13;&#10;                Serial.println(&quot;Coin pin mode: INPUT (floating)&quot;);&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;Usage: coinpull up|down|float&quot;);&#13;&#10;            }&#13;&#10;        } else if (command.startsWith(&quot;coinset&quot;)) {&#13;&#10;            // coinset min 500 | max 300000 | gap 400000 | stab 3000 | burst 1&#13;&#10;            // parse simple tokens&#13;&#10;            if (command.indexOf(&quot;min&quot;) != -1) {&#13;&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#13;&#10;                if (v &gt; 50 &amp;&amp; v &lt; 1000000) { minPulseUs = (unsigned long)v; Serial.print(&quot;minPulseUs=&quot;); Serial.println(minPulseUs); }&#13;&#10;                else Serial.println(&quot;min must be 50..1000000 us&quot;);&#13;&#10;            } else if (command.indexOf(&quot;max&quot;) != -1) {&#13;&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#13;&#10;                if (v &gt; 100 &amp;&amp; v &lt; 2000000) { maxPulseUs = (unsigned long)v; Serial.print(&quot;maxPulseUs=&quot;); Serial.println(maxPulseUs); }&#13;&#10;                else Serial.println(&quot;max must be 100..2000000 us&quot;);&#13;&#10;            } else if (command.indexOf(&quot;gap&quot;) != -1) {&#13;&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#13;&#10;                if (v &gt; 1000 &amp;&amp; v &lt; 3000000) { coinGapUs = (unsigned long)v; Serial.print(&quot;coinGapUs=&quot;); Serial.println(coinGapUs); }&#13;&#10;                else Serial.println(&quot;gap must be 1000..3000000 us&quot;);&#13;&#10;            } else if (command.indexOf(&quot;stab&quot;) != -1) {&#13;&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#13;&#10;                if (v &gt;= 0 &amp;&amp; v &lt; 30000) { coinPowerStabilizeMs = (unsigned long)v; Serial.print(&quot;coinPowerStabilizeMs=&quot;); Serial.println(coinPowerStabilizeMs); }&#13;&#10;                else Serial.println(&quot;stab must be 0..30000 ms&quot;);&#13;&#10;            } else if (command.indexOf(&quot;burst&quot;) != -1) {&#13;&#10;                long v = command.substring(command.lastIndexOf(&quot; &quot;) + 1).toInt();&#13;&#10;                if (v &gt;= 1 &amp;&amp; v &lt;= 10) { minBurstPulses = (uint8_t)v; Serial.print(&quot;minBurstPulses=&quot;); Serial.println(minBurstPulses); }&#13;&#10;                else Serial.println(&quot;burst must be 1..10&quot;);&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;Usage: coinset min|max|gap|stab|burst &lt;value&gt;&quot;);&#13;&#10;            }&#13;&#10;        } else if (command == &quot;coinshow&quot;) {&#13;&#10;            Serial.println(&quot;=== COIN SETTINGS ===&quot;);&#13;&#10;            Serial.print(&quot;Polarity: ACTIVE-&quot;); Serial.println(coinActiveLow ? &quot;LOW&quot; : &quot;HIGH&quot;);&#13;&#10;            Serial.print(&quot;Pin mode: &quot;);&#13;&#10;            // can't directly read mode; show suggestion&#13;&#10;            Serial.println(&quot;see last coinpull command&quot;);&#13;&#10;            Serial.print(&quot;minPulseUs=&quot;); Serial.println(minPulseUs);&#13;&#10;            Serial.print(&quot;maxPulseUs=&quot;); Serial.println(maxPulseUs);&#13;&#10;            Serial.print(&quot;coinGapUs=&quot;); Serial.println(coinGapUs);&#13;&#10;            Serial.print(&quot;coinPowerStabilizeMs=&quot;); Serial.println(coinPowerStabilizeMs);&#13;&#10;            Serial.print(&quot;minBurstPulses=&quot;); Serial.println(minBurstPulses);&#13;&#10;            Serial.println(&quot;=====================&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;void checkQueueStatus() {&#13;&#10;    Serial.println(&quot;\n=== DRIVER QUEUE STATUS ===&quot;);&#13;&#10;&#13;&#10;    if (Firebase.RTDB.get(&amp;fbdo, &quot;/queue&quot;)) {&#13;&#10;        if (fbdo.dataType() == &quot;json&quot;) {&#13;&#10;            String jsonStr = fbdo.jsonString();&#13;&#10;&#13;&#10;            if (jsonStr == &quot;null&quot; || jsonStr.length() == 0) {&#13;&#10;                Serial.println(&quot;Queue is empty&quot;);&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;Queue data:&quot;);&#13;&#10;&#13;&#10;                // Parse and display queue entries with readable timestamps&#13;&#10;                int driverCount = 0;&#13;&#10;                int pos = 0;&#13;&#10;                while ((pos = jsonStr.indexOf(&quot;\&quot;driverName\&quot;&quot;, pos)) != -1) {&#13;&#10;                    driverCount++;&#13;&#10;&#13;&#10;                    // Find the driver name&#13;&#10;                    int nameStart = jsonStr.indexOf(&quot;\&quot;&quot;, pos + 12) + 1;&#13;&#10;                    int nameEnd = jsonStr.indexOf(&quot;\&quot;&quot;, nameStart);&#13;&#10;                    String driverName = jsonStr.substring(nameStart, nameEnd);&#13;&#10;&#13;&#10;                    // Find the timestamp (look backwards for the key)&#13;&#10;                    int keyEnd = jsonStr.lastIndexOf(&quot;\&quot;:&quot;, pos);&#13;&#10;                    int keyStart = jsonStr.lastIndexOf(&quot;\&quot;&quot;, keyEnd - 1) + 1;&#13;&#10;                    String queueKey = jsonStr.substring(keyStart, keyEnd);&#13;&#10;&#13;&#10;                    // Find the readable timestamp&#13;&#10;                    int timestampPos = jsonStr.indexOf(&quot;\&quot;timestamp\&quot;:&quot;, pos);&#13;&#10;                    String readableTime = &quot;&quot;;&#13;&#10;                    if (timestampPos != -1 &amp;&amp; timestampPos &lt; jsonStr.indexOf(&quot;\&quot;driverName\&quot;&quot;, pos + 1)) {&#13;&#10;                        int timeStart = jsonStr.indexOf(&quot;\&quot;&quot;, timestampPos + 12) + 1;&#13;&#10;                        int timeEnd = jsonStr.indexOf(&quot;\&quot;&quot;, timeStart);&#13;&#10;                        readableTime = jsonStr.substring(timeStart, timeEnd);&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Serial.println(&quot;Driver #&quot; + String(driverCount) + &quot;: &quot; + driverName +&#13;&#10;                                   &quot; (Queue: &quot; + queueKey + &quot;, Time: &quot; + readableTime + &quot;)&quot;);&#13;&#10;&#13;&#10;                    pos++;&#13;&#10;                }&#13;&#10;                Serial.println(&quot;Total drivers in queue: &quot; + String(driverCount));&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            Serial.println(&quot;Queue data type: &quot; + fbdo.dataType());&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        // Firebase removes empty nodes, so &quot;path not exist&quot; means no drivers in queue&#13;&#10;        if (fbdo.errorReason().indexOf(&quot;path not exist&quot;) != -1 ||&#13;&#10;            fbdo.errorReason().indexOf(&quot;not found&quot;) != -1 ||&#13;&#10;            fbdo.httpCode() == 404) {&#13;&#10;            Serial.println(&quot;No drivers available in queue&quot;);&#13;&#10;        } else {&#13;&#10;            Serial.println(&quot;✗ Failed to get queue: &quot; + fbdo.errorReason());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    Serial.println(&quot;===========================\n&quot;);&#13;&#10;}&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;void checkForRFIDCard() {&#13;&#10;    // Don't check for RFID if we're already processing one&#13;&#10;    if (isProcessingRFID) {&#13;&#10;        return;&#13;&#10;    }&#13;&#10;&#13;&#10;    uint8_t uid[7];&#13;&#10;    uint8_t uidLength;&#13;&#10;&#13;&#10;    if (nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &amp;uidLength)) {&#13;&#10;        // Convert UID to string&#13;&#10;        String uidString = &quot;&quot;;&#13;&#10;        for (uint8_t i = 0; i &lt; uidLength; i++) {&#13;&#10;            if (uid[i] &lt; 0x10) uidString += &quot;0&quot;;&#13;&#10;            uidString += String(uid[i], HEX);&#13;&#10;        }&#13;&#10;        uidString.toUpperCase();&#13;&#10;&#13;&#10;        // Check for debounce - prevent same card from being processed too quickly&#13;&#10;        if (uidString == lastScannedUID &amp;&amp; (millis() - lastScanTime &lt; SCAN_DEBOUNCE_TIME)) {&#13;&#10;            return; // Ignore duplicate scan within debounce time&#13;&#10;        }&#13;&#10;&#13;&#10;        Serial.print(&quot;Driver RFID scanned: &quot;);&#13;&#10;        Serial.println(uidString);&#13;&#10;&#13;&#10;        // Update debounce variables&#13;&#10;        lastScannedUID = uidString;&#13;&#10;        lastScanTime = millis();&#13;&#10;        isProcessingRFID = true;&#13;&#10;&#13;&#10;        // Check driver registration in database&#13;&#10;        checkDriverRegistration(uidString);&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;void checkDriverRegistration(String rfidUID) {&#13;&#10;    Serial.println(&quot;Checking driver registration using RFID index...&quot;);&#13;&#10;    Serial.println(&quot;Looking up RFID: &quot; + rfidUID);&#13;&#10;&#13;&#10;    fbdo.clear();&#13;&#10;&#13;&#10;    // Step 1: Use the new rfidUIDIndex for instant driver ID lookup&#13;&#10;    String indexPath = &quot;/rfidUIDIndex/&quot; + rfidUID;&#13;&#10;&#13;&#10;    if (Firebase.RTDB.getString(&amp;fbdo, indexPath)) {&#13;&#10;        String driverId = fbdo.stringData();&#13;&#10;&#13;&#10;        if (driverId.length() == 0 || driverId == &quot;null&quot;) {&#13;&#10;            Serial.println(&quot;✗ RFID not found in index: &quot; + rfidUID);&#13;&#10;            showError(&quot;RFID not registered. Please register driver first.&quot;);&#13;&#10;            delay(2000);&#13;&#10;            isProcessingRFID = false;&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        Serial.println(&quot;✓ Driver ID found in index: &quot; + driverId);&#13;&#10;&#13;&#10;        // Step 2: Fetch the full driver data using the driver ID&#13;&#10;        String driverPath = &quot;/drivers/&quot; + driverId;&#13;&#10;        FirebaseData fbdo2; // Use separate FirebaseData object&#13;&#10;&#13;&#10;        if (Firebase.RTDB.get(&amp;fbdo2, driverPath)) {&#13;&#10;            if (fbdo2.dataType() == &quot;json&quot;) {&#13;&#10;                String driverJson = fbdo2.jsonString();&#13;&#10;&#13;&#10;                // Parse essential driver fields&#13;&#10;                int nameStart = driverJson.indexOf(&quot;\&quot;driverName\&quot;:\&quot;&quot;) + 14;&#13;&#10;                int nameEnd = (nameStart &gt;= 14) ? driverJson.indexOf(&quot;\&quot;&quot;, nameStart) : -1;&#13;&#10;                String driverName = (nameStart &gt;= 14 &amp;&amp; nameEnd &gt; nameStart) ? driverJson.substring(nameStart, nameEnd) : &quot;&quot;;&#13;&#10;&#13;&#10;                int todaStart = driverJson.indexOf(&quot;\&quot;todaNumber\&quot;:\&quot;&quot;) + 14;&#13;&#10;                int todaEnd = (todaStart &gt;= 14) ? driverJson.indexOf(&quot;\&quot;&quot;, todaStart) : -1;&#13;&#10;                String todaNumber = (todaStart &gt;= 14 &amp;&amp; todaEnd &gt; todaStart) ? driverJson.substring(todaStart, todaEnd) : &quot;&quot;;&#13;&#10;&#13;&#10;                // Check if driver is active&#13;&#10;                bool isActive = true;&#13;&#10;                int activePos = driverJson.indexOf(&quot;\&quot;isActive\&quot;:&quot;);&#13;&#10;                if (activePos != -1) {&#13;&#10;                    int vStart = activePos + 11;&#13;&#10;                    String v = driverJson.substring(vStart, min((int)driverJson.length(), vStart + 5));&#13;&#10;                    v.trim();&#13;&#10;                    isActive = v.startsWith(&quot;true&quot;);&#13;&#10;                }&#13;&#10;&#13;&#10;                // New: parse paymentMode (default to pay_every_trip)&#13;&#10;                String paymentMode = &quot;pay_every_trip&quot;;&#13;&#10;                int pmPos = driverJson.indexOf(&quot;\&quot;paymentMode\&quot;:\&quot;&quot;);&#13;&#10;                if (pmPos != -1) {&#13;&#10;                    int pmStart = pmPos + 15;&#13;&#10;                    int pmEnd = driverJson.indexOf(&quot;\&quot;&quot;, pmStart);&#13;&#10;                    if (pmEnd &gt; pmStart) {&#13;&#10;                        paymentMode = driverJson.substring(pmStart, pmEnd);&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                if (!isActive) {&#13;&#10;                    Serial.println(&quot;✗ Driver is inactive&quot;);&#13;&#10;                    showError(&quot;Driver account inactive. Please contact admin.&quot;);&#13;&#10;                    delay(2000);&#13;&#10;                    isProcessingRFID = false;&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;&#13;&#10;                if (driverName.length() &gt; 0 &amp;&amp; todaNumber.length() &gt; 0) {&#13;&#10;                    Driver driver;&#13;&#10;                    driver.rfidUID = rfidUID;&#13;&#10;                    driver.driverName = driverName;&#13;&#10;                    driver.todaNumber = todaNumber;&#13;&#10;                    driver.isRegistered = true;&#13;&#10;                    driver.driverId = driverId; // New&#13;&#10;                    driver.paymentMode = paymentMode; // New&#13;&#10;&#13;&#10;                    Serial.println(&quot;✓ Driver found via RFID index:&quot;);&#13;&#10;                    Serial.println(&quot;  Driver ID: &quot; + driverId);&#13;&#10;                    Serial.println(&quot;  Name: &quot; + driver.driverName);&#13;&#10;                    Serial.println(&quot;  TODA Number: &quot; + driver.todaNumber);&#13;&#10;                    Serial.println(&quot;  Payment Mode: &quot; + driver.paymentMode);&#13;&#10;&#13;&#10;                    // Branch by payment mode&#13;&#10;                    if (driver.paymentMode == &quot;pay_later&quot;) {&#13;&#10;                        Serial.println(&quot;Payment mode is PAY LATER - will queue without coin and increment balance.&quot;);&#13;&#10;                        processPayLaterAndQueue(driver);&#13;&#10;                        isProcessingRFID = false;&#13;&#10;                        return;&#13;&#10;                    } else {&#13;&#10;                        enableCoinSlot(driver);&#13;&#10;                        delay(1000);&#13;&#10;                        isProcessingRFID = false;&#13;&#10;                        return;&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    Serial.println(&quot;✗ Incomplete driver data&quot;);&#13;&#10;                    showError(&quot;Driver record incomplete. Please contact admin.&quot;);&#13;&#10;                    delay(2000);&#13;&#10;                    isProcessingRFID = false;&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;✗ Driver data is not JSON: &quot; + fbdo2.dataType());&#13;&#10;                showError(&quot;Invalid driver data format. Please contact admin.&quot;);&#13;&#10;                delay(2000);&#13;&#10;                isProcessingRFID = false;&#13;&#10;                return;&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            Serial.println(&quot;✗ Failed to fetch driver data: &quot; + fbdo2.errorReason());&#13;&#10;            showError(&quot;Failed to read driver data. Please try again.&quot;);&#13;&#10;            delay(2000);&#13;&#10;            isProcessingRFID = false;&#13;&#10;            return;&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        String error = fbdo.errorReason();&#13;&#10;        Serial.println(&quot;✗ Failed to lookup RFID index: &quot; + error);&#13;&#10;&#13;&#10;        // Check if it's a &quot;not found&quot; error vs connection error&#13;&#10;        if (error.indexOf(&quot;not exist&quot;) != -1 || error.indexOf(&quot;null&quot;) != -1) {&#13;&#10;            showError(&quot;RFID not registered. Please register driver first.&quot;);&#13;&#10;        } else {&#13;&#10;            showError(&quot;Database connection error. Check WiFi.&quot;);&#13;&#10;        }&#13;&#10;        delay(2000);&#13;&#10;        isProcessingRFID = false;&#13;&#10;        return;&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;&#13;&#10;void enableCoinSlot(Driver driver) {&#13;&#10;    Serial.println(&quot;\n=== ENABLING COIN SLOT ===&quot;);&#13;&#10;&#13;&#10;    // FIRST: Check if driver is already in queue before enabling coin slot&#13;&#10;    Serial.println(&quot;Checking if driver is already in queue before enabling coin slot...&quot;);&#13;&#10;&#13;&#10;    if (isDriverAlreadyWaiting(driver.rfidUID)) {&#13;&#10;        Serial.println(&quot;✗ Driver &quot; + driver.driverName + &quot; is already in the queue!&quot;);&#13;&#10;        Serial.println(&quot;Coin slot will NOT be enabled. Please wait for your turn.&quot;);&#13;&#10;        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#13;&#10;&#13;&#10;        // Display error on LCD&#13;&#10;        updateLCDDisplay(driver.todaNumber, &quot;Already in Queue!&quot;);&#13;&#10;        delay(3000); // Show error for 3 seconds&#13;&#10;        clearLCDDisplay();&#13;&#10;&#13;&#10;        // Reset processing flag and re-enable NFC immediately&#13;&#10;        isProcessingRFID = false;&#13;&#10;        nfcEnabled = true;&#13;&#10;        coinSlotEnabled = false;&#13;&#10;        return; // Exit without enabling coin slot&#13;&#10;    }&#13;&#10;&#13;&#10;    Serial.println(&quot;Driver not in queue, proceeding to enable coin slot...&quot;);&#13;&#10;&#13;&#10;    // Disable NFC to prevent interference&#13;&#10;    nfcEnabled = false;&#13;&#10;    coinSlotEnabled = true;&#13;&#10;    isProcessingRFID = false; // Allow processing to continue&#13;&#10;&#13;&#10;    // Reset coin pulse counters and mark power-on time&#13;&#10;    noInterrupts();&#13;&#10;    coinValidPulses = 0;&#13;&#10;    coinActive = false;&#13;&#10;    interrupts();&#13;&#10;    coinSlotPowerOnTime = millis();&#13;&#10;&#13;&#10;    Serial.println(&quot;NFC disabled: &quot; + String(nfcEnabled ? &quot;false&quot; : &quot;true&quot;));&#13;&#10;    Serial.println(&quot;Coin slot enabled: &quot; + String(coinSlotEnabled ? &quot;true&quot; : &quot;false&quot;));&#13;&#10;&#13;&#10;    // Send command to Arduino to power on coin slot&#13;&#10;    Serial.println(&quot;Sending command 200 to Arduino via Serial2...&quot;);&#13;&#10;    Serial2.write((uint8_t)200);&#13;&#10;    Serial2.flush(); // Ensure data is sent&#13;&#10;&#13;&#10;    Serial.println(&quot;✓ Command sent to Arduino&quot;);&#13;&#10;    Serial.println(&quot;RFID verified! PN532 disabled. Coin slot enabled - insert ₱&quot; + String(CONTRIBUTION_AMOUNT) + &quot; contribution.&quot;);&#13;&#10;    Serial.println(&quot;Driver: &quot; + driver.driverName + &quot; (TODA #&quot; + driver.todaNumber + &quot;)&quot;);&#13;&#10;&#13;&#10;    // Store current driver info for contribution processing&#13;&#10;    currentDriver = driver;&#13;&#10;&#13;&#10;    // Display on LCD: TODA-001 INSERT X&#13;&#10;    updateLCDDisplay(driver.todaNumber, &quot;INSERT &quot; + String(CONTRIBUTION_AMOUNT));&#13;&#10;&#13;&#10;    Serial.println(&quot;=== COIN SLOT READY ===\n&quot;);&#13;&#10;}&#13;&#10;&#13;&#10;void processCoinContribution() {&#13;&#10;    totalSavings += CONTRIBUTION_AMOUNT;&#13;&#10;    Serial.println(&quot;₱&quot; + String(CONTRIBUTION_AMOUNT) + &quot; contribution received from &quot; + currentDriver.driverName);&#13;&#10;    Serial.println(&quot;Total today: ₱&quot; + String(totalSavings));&#13;&#10;&#13;&#10;    // Display success message on LCD&#13;&#10;    updateLCDDisplay(currentDriver.todaNumber, &quot;Payment Success!&quot;);&#13;&#10;    delay(2000); // Show success message for 2 seconds&#13;&#10;&#13;&#10;    // Send command to Arduino to power off coin slot&#13;&#10;    Serial2.write((uint8_t)201);&#13;&#10;    Serial2.flush();&#13;&#10;&#13;&#10;    // Process contribution and add to queue&#13;&#10;    processContributionAndQueue();&#13;&#10;&#13;&#10;    // Re-enable NFC for next driver&#13;&#10;    coinSlotEnabled = false;&#13;&#10;    nfcEnabled = true;&#13;&#10;    isProcessingRFID = false; // Make sure RFID processing flag is cleared&#13;&#10;&#13;&#10;    // Clear coin pulses to avoid re-trigger&#13;&#10;    noInterrupts();&#13;&#10;    coinValidPulses = 0;&#13;&#10;    coinActive = false;&#13;&#10;    interrupts();&#13;&#10;&#13;&#10;    // Clear LCD and show system ready message&#13;&#10;    clearLCDDisplay();&#13;&#10;&#13;&#10;    Serial.println(&quot;Contribution processed! PN532 re-enabled. Next driver can scan RFID.&quot;);&#13;&#10;    Serial.println(&quot;System ready for next driver...&quot;);&#13;&#10;}&#13;&#10;&#13;&#10;void processContributionAndQueue() {&#13;&#10;    Serial.println(&quot;Processing contribution and adding to queue...&quot;);&#13;&#10;&#13;&#10;    // Record contribution in database&#13;&#10;    recordContribution();&#13;&#10;&#13;&#10;    // Add driver to queue&#13;&#10;    addDriverToQueue();&#13;&#10;}&#13;&#10;&#13;&#10;void recordContribution() {&#13;&#10;    // Create contribution record JSON&#13;&#10;    String timestamp = String(time(nullptr));&#13;&#10;    String contributionPath = &quot;/contributions/&quot; + timestamp;&#13;&#10;&#13;&#10;    FirebaseJson contributionJson;&#13;&#10;    contributionJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#13;&#10;    contributionJson.set(&quot;driverName&quot;, currentDriver.driverName);&#13;&#10;    contributionJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#13;&#10;    contributionJson.set(&quot;amount&quot;, CONTRIBUTION_AMOUNT);&#13;&#10;    contributionJson.set(&quot;timestamp&quot;, timestamp);&#13;&#10;    contributionJson.set(&quot;date&quot;, getCurrentDate());&#13;&#10;&#13;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, contributionPath, &amp;contributionJson)) {&#13;&#10;        Serial.println(&quot;✓ Contribution recorded in database&quot;);&#13;&#10;    } else {&#13;&#10;        Serial.println(&quot;✗ Failed to record contribution: &quot; + fbdo.errorReason());&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// New: process pay-later flow&#13;&#10;void processPayLaterAndQueue(Driver driver) {&#13;&#10;    Serial.println(&quot;\n=== PAY LATER FLOW ===&quot;);&#13;&#10;&#13;&#10;    // Check duplicate in queue first using lightweight index&#13;&#10;    Serial.println(&quot;Checking if driver is already in queue (pay_later)...&quot;);&#13;&#10;    if (isDriverAlreadyWaiting(driver.rfidUID)) {&#13;&#10;        Serial.println(&quot;✗ Driver &quot; + driver.driverName + &quot; is already in the queue!&quot;);&#13;&#10;        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#13;&#10;        updateLCDDisplay(driver.todaNumber, &quot;Already in Queue!&quot;);&#13;&#10;        delay(3000);&#13;&#10;        clearLCDDisplay();&#13;&#10;        return;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Increment driver's balance by contribution amount&#13;&#10;    String balancePath = &quot;/drivers/&quot; + driver.driverId + &quot;/balance&quot;;&#13;&#10;    long currentBalance = 0;&#13;&#10;    bool gotBalance = false;&#13;&#10;    if (Firebase.RTDB.getInt(&amp;fbdo, balancePath)) {&#13;&#10;        currentBalance = fbdo.intData();&#13;&#10;        gotBalance = true;&#13;&#10;    } else {&#13;&#10;        String err = fbdo.errorReason();&#13;&#10;        // If path not exist, treat as zero&#13;&#10;        if (err.indexOf(&quot;not exist&quot;) != -1 || fbdo.httpCode() == 404) {&#13;&#10;            currentBalance = 0;&#13;&#10;            gotBalance = true;&#13;&#10;        } else {&#13;&#10;            // Fallback: try reading as string and parse&#13;&#10;            FirebaseData fbdoStr;&#13;&#10;            if (Firebase.RTDB.getString(&amp;fbdoStr, balancePath)) {&#13;&#10;                String balStr = fbdoStr.stringData();&#13;&#10;                balStr.trim();&#13;&#10;                currentBalance = balStr.toInt();&#13;&#10;                gotBalance = true;&#13;&#10;                Serial.println(&quot;Balance read as string: '&quot; + balStr + &quot;' -&gt; &quot; + String(currentBalance));&#13;&#10;            } else {&#13;&#10;                Serial.println(&quot;✗ Failed to read balance: &quot; + err);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    if (gotBalance) {&#13;&#10;        long newBalance = currentBalance + CONTRIBUTION_AMOUNT;&#13;&#10;        if (Firebase.RTDB.setInt(&amp;fbdo, balancePath, newBalance)) {&#13;&#10;            Serial.println(&quot;✓ Balance updated: &quot; + String(currentBalance) + &quot; -&gt; &quot; + String(newBalance));&#13;&#10;        } else {&#13;&#10;            Serial.println(&quot;✗ Failed to update balance: &quot; + fbdo.errorReason());&#13;&#10;            showError(&quot;Failed to update balance. Try again.&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        showError(&quot;Unable to read current balance.&quot;);&#13;&#10;        return;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Set current driver and add to queue with contributionPaid=false&#13;&#10;    currentDriver = driver;&#13;&#10;    addDriverToQueueWithPaid(false);&#13;&#10;&#13;&#10;    // Keep NFC ON, coin slot OFF&#13;&#10;    coinSlotEnabled = false;&#13;&#10;    nfcEnabled = true;&#13;&#10;&#13;&#10;    // Show LCD message (fit 16 chars)&#13;&#10;    updateLCDDisplay(driver.todaNumber, &quot;Queued PayLater&quot;);&#13;&#10;    delay(2000);&#13;&#10;    clearLCDDisplay();&#13;&#10;&#13;&#10;    Serial.println(&quot;Pay-later processing completed. Driver queued without coin.&quot;);&#13;&#10;}&#13;&#10;&#13;&#10;void addDriverToQueue() {&#13;&#10;    Serial.println(&quot;Checking if driver is already in queue...&quot;);&#13;&#10;&#13;&#10;    // First, check if driver is already in the queue via index&#13;&#10;    if (isDriverAlreadyWaiting(currentDriver.rfidUID)) {&#13;&#10;        Serial.println(&quot;✗ Driver &quot; + currentDriver.driverName + &quot; is already in the queue!&quot;);&#13;&#10;        Serial.println(&quot;Please wait for your turn or check with the operator.&quot;);&#13;&#10;        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#13;&#10;        return; // Exit without adding to queue&#13;&#10;    }&#13;&#10;&#13;&#10;    Serial.println(&quot;Driver not in queue, adding to queue...&quot;);&#13;&#10;&#13;&#10;    // Create queue entry JSON&#13;&#10;    String timestamp = String(time(nullptr));&#13;&#10;    String queuePath = &quot;/queue/&quot; + timestamp;&#13;&#10;&#13;&#10;    FirebaseJson queueJson;&#13;&#10;    queueJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#13;&#10;    queueJson.set(&quot;driverName&quot;, currentDriver.driverName);&#13;&#10;    queueJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#13;&#10;    queueJson.set(&quot;queueTime&quot;, timestamp);&#13;&#10;    queueJson.set(&quot;timestamp&quot;, getCurrentDate() + &quot; &quot; + getCurrentTime()); // Real-time readable timestamp&#13;&#10;    queueJson.set(&quot;status&quot;, &quot;waiting&quot;);&#13;&#10;    queueJson.set(&quot;contributionPaid&quot;, true);&#13;&#10;&#13;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, queuePath, &amp;queueJson)) {&#13;&#10;        Serial.println(&quot;✓ Driver added to queue successfully!&quot;);&#13;&#10;        Serial.println(&quot;Driver &quot; + currentDriver.driverName + &quot; is now in the tricycle queue&quot;);&#13;&#10;        Serial.println(&quot;Queue Time: &quot; + getCurrentDate() + &quot; &quot; + getCurrentTime());&#13;&#10;        // Write lightweight index for duplicate checks&#13;&#10;        String idxPath = &quot;/queueIndexByRFID/&quot; + currentDriver.rfidUID + &quot;/&quot; + timestamp;&#13;&#10;        if (!Firebase.RTDB.setBool(&amp;fbdo, idxPath, true)) {&#13;&#10;            Serial.println(&quot;! Note: failed to write queue index: &quot; + fbdo.errorReason());&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        Serial.println(&quot;✗ Failed to add driver to queue: &quot; + fbdo.errorReason());&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// New: same as addDriverToQueue but configurable contributionPaid flag&#13;&#10;void addDriverToQueueWithPaid(bool paid) {&#13;&#10;    Serial.println(&quot;Adding driver to queue (paid=&quot; + String(paid ? &quot;true&quot; : &quot;false&quot;) + &quot;)...&quot;);&#13;&#10;&#13;&#10;    // Duplicate check using the same efficient index&#13;&#10;    if (isDriverAlreadyWaiting(currentDriver.rfidUID)) {&#13;&#10;        Serial.println(&quot;✗ Driver &quot; + currentDriver.driverName + &quot; is already in the queue!&quot;);&#13;&#10;        showError(&quot;Already in queue! Please wait for your turn.&quot;);&#13;&#10;        return;&#13;&#10;    }&#13;&#10;&#13;&#10;    String timestamp = String(time(nullptr));&#13;&#10;    String queuePath = &quot;/queue/&quot; + timestamp;&#13;&#10;&#13;&#10;    FirebaseJson queueJson;&#13;&#10;    queueJson.set(&quot;driverRFID&quot;, currentDriver.rfidUID);&#13;&#10;    queueJson.set(&quot;driverName&quot;, currentDriver.driverName);&#13;&#10;    queueJson.set(&quot;todaNumber&quot;, currentDriver.todaNumber);&#13;&#10;    queueJson.set(&quot;queueTime&quot;, timestamp);&#13;&#10;    queueJson.set(&quot;timestamp&quot;, getCurrentDate() + &quot; &quot; + getCurrentTime());&#13;&#10;    queueJson.set(&quot;status&quot;, &quot;waiting&quot;);&#13;&#10;    queueJson.set(&quot;contributionPaid&quot;, paid);&#13;&#10;&#13;&#10;    if (Firebase.RTDB.setJSON(&amp;fbdo, queuePath, &amp;queueJson)) {&#13;&#10;        Serial.println(&quot;✓ Driver added to queue successfully (paid=&quot; + String(paid ? &quot;true&quot; : &quot;false&quot;) + &quot;)&quot;);&#13;&#10;        // Write lightweight index for duplicate checks&#13;&#10;        String idxPath = &quot;/queueIndexByRFID/&quot; + currentDriver.rfidUID + &quot;/&quot; + timestamp;&#13;&#10;        if (!Firebase.RTDB.setBool(&amp;fbdo, idxPath, true)) {&#13;&#10;            Serial.println(&quot;! Note: failed to write queue index: &quot; + fbdo.errorReason());&#13;&#10;        }&#13;&#10;    } else {&#13;&#10;        Serial.println(&quot;✗ Failed to add driver to queue: &quot; + fbdo.errorReason());&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// New: Efficient duplicate check using small index path (no QueryFilter)&#13;&#10;bool isDriverAlreadyWaiting(const String &amp;rfid) {&#13;&#10;    FirebaseData fbdoCheck;&#13;&#10;    String idxPath = &quot;/queueIndexByRFID/&quot; + rfid;&#13;&#10;    if (!Firebase.RTDB.get(&amp;fbdoCheck, idxPath)) {&#13;&#10;        String err = fbdoCheck.errorReason();&#13;&#10;        if (err.indexOf(&quot;path not exist&quot;) != -1 || err.indexOf(&quot;not found&quot;) != -1 || fbdoCheck.httpCode() == 404) {&#13;&#10;            return false; // no index for this RFID -&gt; not waiting&#13;&#10;        }&#13;&#10;        Serial.println(&quot;✗ Duplicate check failed: &quot; + err);&#13;&#10;        return false; // fail-safe: treat as not waiting&#13;&#10;    }&#13;&#10;&#13;&#10;    if (fbdoCheck.dataType() != &quot;json&quot;) {&#13;&#10;        return false;&#13;&#10;    }&#13;&#10;&#13;&#10;    String json = fbdoCheck.jsonString();&#13;&#10;    if (json == &quot;null&quot; || json.length() == 0) return false;&#13;&#10;&#13;&#10;    int brace = json.indexOf('{');&#13;&#10;    int next = json.indexOf('}', brace + 1);&#13;&#10;    return next - brace &gt; 1; // has at least one child&#13;&#10;}&#13;&#10;&#13;&#10;void showError(String message) {&#13;&#10;    Serial.println(&quot;ERROR: &quot; + message);&#13;&#10;    Serial.println(&quot;Please try scanning the RFID card again...&quot;);&#13;&#10;    // Here you could add LED indicators, buzzer, or display messages&#13;&#10;}&#13;&#10;&#13;&#10;String getCurrentDate() {&#13;&#10;    time_t now = time(nullptr);&#13;&#10;    struct tm* timeinfo = localtime(&amp;now);&#13;&#10;&#13;&#10;    char dateStr[11];&#13;&#10;    sprintf(dateStr, &quot;%04d-%02d-%02d&quot;,&#13;&#10;            timeinfo-&gt;tm_year + 1900,&#13;&#10;            timeinfo-&gt;tm_mon + 1,&#13;&#10;            timeinfo-&gt;tm_mday);&#13;&#10;&#13;&#10;    return String(dateStr);&#13;&#10;}&#13;&#10;&#13;&#10;String getCurrentTime() {&#13;&#10;    time_t now = time(nullptr);&#13;&#10;    struct tm* timeinfo = localtime(&amp;now);&#13;&#10;&#13;&#10;    char timeStr[9];&#13;&#10;    sprintf(timeStr, &quot;%02d:%02d:%02d&quot;,&#13;&#10;            timeinfo-&gt;tm_hour,&#13;&#10;            timeinfo-&gt;tm_min,&#13;&#10;            timeinfo-&gt;tm_sec);&#13;&#10;&#13;&#10;    return String(timeStr);&#13;&#10;}&#13;&#10;&#13;&#10;// LCD Display Functions&#13;&#10;void updateLCDDisplay(String todaNumber, String message) {&#13;&#10;    lcd.clear();&#13;&#10;    lcd.setCursor(0, 0);&#13;&#10;    lcd.print(&quot;TODA-&quot; + todaNumber);&#13;&#10;    lcd.setCursor(0, 1);&#13;&#10;    lcd.print(message);&#13;&#10;&#13;&#10;    Serial.println(&quot;LCD Display Updated:&quot;);&#13;&#10;    Serial.println(&quot;Line 1: TODA-&quot; + todaNumber);&#13;&#10;    Serial.println(&quot;Line 2: &quot; + message);&#13;&#10;}&#13;&#10;&#13;&#10;void clearLCDDisplay() {&#13;&#10;    lcd.clear();&#13;&#10;    lcd.setCursor(0, 0);&#13;&#10;    lcd.print(&quot;System Ready&quot;);&#13;&#10;    lcd.setCursor(0, 1);&#13;&#10;    lcd.print(&quot;Scan RFID Card&quot;);&#13;&#10;&#13;&#10;    Serial.println(&quot;LCD Display Cleared - Ready for next scan&quot;);&#13;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>